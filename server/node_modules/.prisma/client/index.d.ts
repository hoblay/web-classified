
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 */

export type User = {
  id: number
  email: string
  firstName: string
  lastName: string
  password: string
  phone: string
  countyId: number
  zip: string
  isPrivacyEneable: boolean
  role: Role
  languageId: number
}

/**
 * Model Language
 */

export type Language = {
  id: number
  name: string
}

/**
 * Model County
 */

export type County = {
  id: number
  cityId: number
  name: string
}

/**
 * Model City
 */

export type City = {
  id: number
  stateId: number
  name: string
}

/**
 * Model State
 */

export type State = {
  id: number
  countryId: number
  name: string
}

/**
 * Model Country
 */

export type Country = {
  id: number
  currencyId: number
  name: string
}

/**
 * Model Currency
 */

export type Currency = {
  id: number
  code: string
  exchangeRate: number
}

/**
 * Model Payment
 */

export type Payment = {
  id: number
  currencyId: number
  method: string
  status: string
}

/**
 * Model Category
 */

export type Category = {
  id: number
  parentId: number | null
  name: string
  maxImgs: number
  postValidityIntervalInDays: number | null
}

/**
 * Model Property
 */

export type Property = {
  id: number
  categoryId: number
  name: string
  unit: string
  isMandatory: boolean
  screenControlId: number
}

/**
 * Model PossibleValues
 */

export type PossibleValues = {
  id: number
  propertyId: number
  value: number
}

/**
 * Model ScreenControl
 */

export type ScreenControl = {
  id: number
  screenControl: string
}

/**
 * Model Post
 */

export type Post = {
  id: number
  userId: number
  categoryId: number
  createdAt: Date
  lastRenewedAt: Date
  title: string
  detail: string
  isActive: boolean
  isSeller: boolean
  isIndividual: boolean
  expectedPrice: number | null
  isPriceNegotiable: boolean
}

/**
 * Model Image
 */

export type Image = {
  id: number
  postId: number
  name: string
  url: string
}

/**
 * Model Attribute
 */

export type Attribute = {
  id: number
}

/**
 * Model AttributeValues
 */

export type AttributeValues = {
  id: number
  attributeId: number
  value: number
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<GlobalReject>;

  /**
   * `prisma.county`: Exposes CRUD operations for the **County** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counties
    * const counties = await prisma.county.findMany()
    * ```
    */
  get county(): Prisma.CountyDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<GlobalReject>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **State** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.StateDelegate<GlobalReject>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<GlobalReject>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<GlobalReject>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<GlobalReject>;

  /**
   * `prisma.possibleValues`: Exposes CRUD operations for the **PossibleValues** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PossibleValues
    * const possibleValues = await prisma.possibleValues.findMany()
    * ```
    */
  get possibleValues(): Prisma.PossibleValuesDelegate<GlobalReject>;

  /**
   * `prisma.screenControl`: Exposes CRUD operations for the **ScreenControl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScreenControls
    * const screenControls = await prisma.screenControl.findMany()
    * ```
    */
  get screenControl(): Prisma.ScreenControlDelegate<GlobalReject>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<GlobalReject>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<GlobalReject>;

  /**
   * `prisma.attribute`: Exposes CRUD operations for the **Attribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attributes
    * const attributes = await prisma.attribute.findMany()
    * ```
    */
  get attribute(): Prisma.AttributeDelegate<GlobalReject>;

  /**
   * `prisma.attributeValues`: Exposes CRUD operations for the **AttributeValues** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttributeValues
    * const attributeValues = await prisma.attributeValues.findMany()
    * ```
    */
  get attributeValues(): Prisma.AttributeValuesDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.21.0
   * Query Engine version: e421996c87d5f3c8f7eeadd502d4ad402c89464d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Language: 'Language',
    County: 'County',
    City: 'City',
    State: 'State',
    Country: 'Country',
    Currency: 'Currency',
    Payment: 'Payment',
    Category: 'Category',
    Property: 'Property',
    PossibleValues: 'PossibleValues',
    ScreenControl: 'ScreenControl',
    Post: 'Post',
    Image: 'Image',
    Attribute: 'Attribute',
    AttributeValues: 'AttributeValues'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    count: UserCountAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    countyId: number | null
    languageId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    countyId: number | null
    languageId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    phone: string | null
    countyId: number | null
    zip: string | null
    isPrivacyEneable: boolean | null
    role: Role | null
    languageId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    phone: string | null
    countyId: number | null
    zip: string | null
    isPrivacyEneable: boolean | null
    role: Role | null
    languageId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    password: number
    phone: number
    countyId: number
    zip: number
    isPrivacyEneable: number
    role: number
    languageId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    countyId?: true
    languageId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    countyId?: true
    languageId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    phone?: true
    countyId?: true
    zip?: true
    isPrivacyEneable?: true
    role?: true
    languageId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    phone?: true
    countyId?: true
    zip?: true
    isPrivacyEneable?: true
    role?: true
    languageId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    phone?: true
    countyId?: true
    zip?: true
    isPrivacyEneable?: true
    role?: true
    languageId?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: UserCountAggregateInputType | true
    avg?: UserAvgAggregateInputType
    sum?: UserSumAggregateInputType
    min?: UserMinAggregateInputType
    max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    email: string
    firstName: string
    lastName: string
    password: string
    phone: string
    countyId: number
    zip: string
    isPrivacyEneable: boolean
    role: Role
    languageId: number
    count: UserCountAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<Array<
    PickArray<UserGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof UserGroupByOutputType))]: GetScalarType<T[P], UserGroupByOutputType[P]>
    }
  >>
    

  export type UserSelect = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    phone?: boolean
    countyId?: boolean
    zip?: boolean
    isPrivacyEneable?: boolean
    role?: boolean
    language?: boolean | LanguageArgs
    languageId?: boolean
    posts?: boolean | PostFindManyArgs
  }

  export type UserInclude = {
    language?: boolean | LanguageArgs
    posts?: boolean | PostFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'language'
        ? LanguageGetPayload<S['include'][P]> :
        P extends 'posts'
        ? Array < PostGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'language'
        ? LanguageGetPayload<S['select'][P]> :
        P extends 'posts'
        ? Array < PostGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    language<T extends LanguageArgs = {}>(args?: Subset<T, LanguageArgs>): CheckSelect<T, Prisma__LanguageClient<Language | null >, Prisma__LanguageClient<LanguageGetPayload<T> | null >>;

    posts<T extends PostFindManyArgs = {}>(args?: Subset<T, PostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Post>>, PrismaPromise<Array<PostGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
  }



  /**
   * Model Language
   */


  export type AggregateLanguage = {
    count: LanguageCountAggregateOutputType | null
    avg: LanguageAvgAggregateOutputType | null
    sum: LanguageSumAggregateOutputType | null
    min: LanguageMinAggregateOutputType | null
    max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    id: number | null
  }

  export type LanguageSumAggregateOutputType = {
    id: number | null
  }

  export type LanguageMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    id?: true
  }

  export type LanguageSumAggregateInputType = {
    id?: true
  }

  export type LanguageMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type LanguageAggregateArgs = {
    /**
     * Filter which Language to aggregate.
    **/
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
    **/
    orderBy?: Enumerable<LanguageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
    [P in keyof T & keyof AggregateLanguage]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }


    
    
  export type LanguageGroupByArgs = {
    where?: LanguageWhereInput
    orderBy?: Enumerable<LanguageOrderByInput>
    by: Array<LanguageScalarFieldEnum>
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: LanguageCountAggregateInputType | true
    avg?: LanguageAvgAggregateInputType
    sum?: LanguageSumAggregateInputType
    min?: LanguageMinAggregateInputType
    max?: LanguageMaxAggregateInputType
  }


  export type LanguageGroupByOutputType = {
    id: number
    name: string
    count: LanguageCountAggregateOutputType | null
    avg: LanguageAvgAggregateOutputType | null
    sum: LanguageSumAggregateOutputType | null
    min: LanguageMinAggregateOutputType | null
    max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Promise<Array<
    PickArray<LanguageGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: GetScalarType<T[P], LanguageGroupByOutputType[P]>
    }
  >>
    

  export type LanguageSelect = {
    id?: boolean
    name?: boolean
    User?: boolean | UserFindManyArgs
  }

  export type LanguageInclude = {
    User?: boolean | UserFindManyArgs
  }

  export type LanguageGetPayload<
    S extends boolean | null | undefined | LanguageArgs,
    U = keyof S
      > = S extends true
        ? Language
    : S extends undefined
    ? never
    : S extends LanguageArgs | LanguageFindManyArgs
    ?'include' extends U
    ? Language  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? Array < UserGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Language ?Language [P]
  : 
          P extends 'User'
        ? Array < UserGetPayload<S['select'][P]>>  : never
  } 
    : Language
  : Language


  type LanguageCountArgs = Merge<
    Omit<LanguageFindManyArgs, 'select' | 'include'> & {
      select?: LanguageCountAggregateInputType | true
    }
  >

  export interface LanguageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LanguageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LanguageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Language'> extends True ? CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>> : CheckSelect<T, Prisma__LanguageClient<Language | null >, Prisma__LanguageClient<LanguageGetPayload<T> | null >>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LanguageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LanguageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Language'> extends True ? CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>> : CheckSelect<T, Prisma__LanguageClient<Language | null >, Prisma__LanguageClient<LanguageGetPayload<T> | null >>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LanguageFindManyArgs>(
      args?: SelectSubset<T, LanguageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Language>>, PrismaPromise<Array<LanguageGetPayload<T>>>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
    **/
    create<T extends LanguageCreateArgs>(
      args: SelectSubset<T, LanguageCreateArgs>
    ): CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>>

    /**
     * Create many Languages.
     *     @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     *     @example
     *     // Create many Languages
     *     const language = await prisma.language.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LanguageCreateManyArgs>(
      args?: SelectSubset<T, LanguageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
    **/
    delete<T extends LanguageDeleteArgs>(
      args: SelectSubset<T, LanguageDeleteArgs>
    ): CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LanguageUpdateArgs>(
      args: SelectSubset<T, LanguageUpdateArgs>
    ): CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LanguageDeleteManyArgs>(
      args?: SelectSubset<T, LanguageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LanguageUpdateManyArgs>(
      args: SelectSubset<T, LanguageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
    **/
    upsert<T extends LanguageUpsertArgs>(
      args: SelectSubset<T, LanguageUpsertArgs>
    ): CheckSelect<T, Prisma__LanguageClient<Language>, Prisma__LanguageClient<LanguageGetPayload<T>>>

    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LanguageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Language
    **/
    select?: LanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LanguageInclude | null
    /**
     * Throw an Error if a Language can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Language to fetch.
    **/
    where: LanguageWhereUniqueInput
  }


  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Language
    **/
    select?: LanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LanguageInclude | null
    /**
     * Throw an Error if a Language can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Language to fetch.
    **/
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
    **/
    orderBy?: Enumerable<LanguageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
    **/
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
    **/
    distinct?: Enumerable<LanguageScalarFieldEnum>
  }


  /**
   * Language findMany
   */
  export type LanguageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Language
    **/
    select?: LanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LanguageInclude | null
    /**
     * Filter, which Languages to fetch.
    **/
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
    **/
    orderBy?: Enumerable<LanguageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
    **/
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
    **/
    skip?: number
    distinct?: Enumerable<LanguageScalarFieldEnum>
  }


  /**
   * Language create
   */
  export type LanguageCreateArgs = {
    /**
     * Select specific fields to fetch from the Language
    **/
    select?: LanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LanguageInclude | null
    /**
     * The data needed to create a Language.
    **/
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }


  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs = {
    data: Enumerable<LanguageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Language update
   */
  export type LanguageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Language
    **/
    select?: LanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LanguageInclude | null
    /**
     * The data needed to update a Language.
    **/
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
    **/
    where: LanguageWhereUniqueInput
  }


  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs = {
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    where?: LanguageWhereInput
  }


  /**
   * Language upsert
   */
  export type LanguageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Language
    **/
    select?: LanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LanguageInclude | null
    /**
     * The filter to search for the Language to update in case it exists.
    **/
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
    **/
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }


  /**
   * Language delete
   */
  export type LanguageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Language
    **/
    select?: LanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LanguageInclude | null
    /**
     * Filter which Language to delete.
    **/
    where: LanguageWhereUniqueInput
  }


  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs = {
    where?: LanguageWhereInput
  }


  /**
   * Language without action
   */
  export type LanguageArgs = {
    /**
     * Select specific fields to fetch from the Language
    **/
    select?: LanguageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LanguageInclude | null
  }



  /**
   * Model County
   */


  export type AggregateCounty = {
    count: CountyCountAggregateOutputType | null
    avg: CountyAvgAggregateOutputType | null
    sum: CountySumAggregateOutputType | null
    min: CountyMinAggregateOutputType | null
    max: CountyMaxAggregateOutputType | null
  }

  export type CountyAvgAggregateOutputType = {
    id: number | null
    cityId: number | null
  }

  export type CountySumAggregateOutputType = {
    id: number | null
    cityId: number | null
  }

  export type CountyMinAggregateOutputType = {
    id: number | null
    cityId: number | null
    name: string | null
  }

  export type CountyMaxAggregateOutputType = {
    id: number | null
    cityId: number | null
    name: string | null
  }

  export type CountyCountAggregateOutputType = {
    id: number
    cityId: number
    name: number
    _all: number
  }


  export type CountyAvgAggregateInputType = {
    id?: true
    cityId?: true
  }

  export type CountySumAggregateInputType = {
    id?: true
    cityId?: true
  }

  export type CountyMinAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
  }

  export type CountyMaxAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
  }

  export type CountyCountAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    _all?: true
  }

  export type CountyAggregateArgs = {
    /**
     * Filter which County to aggregate.
    **/
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
    **/
    orderBy?: Enumerable<CountyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Counties
    **/
    count?: true | CountyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CountyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CountySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CountyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CountyMaxAggregateInputType
  }

  export type GetCountyAggregateType<T extends CountyAggregateArgs> = {
    [P in keyof T & keyof AggregateCounty]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounty[P]>
      : GetScalarType<T[P], AggregateCounty[P]>
  }


    
    
  export type CountyGroupByArgs = {
    where?: CountyWhereInput
    orderBy?: Enumerable<CountyOrderByInput>
    by: Array<CountyScalarFieldEnum>
    having?: CountyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CountyCountAggregateInputType | true
    avg?: CountyAvgAggregateInputType
    sum?: CountySumAggregateInputType
    min?: CountyMinAggregateInputType
    max?: CountyMaxAggregateInputType
  }


  export type CountyGroupByOutputType = {
    id: number
    cityId: number
    name: string
    count: CountyCountAggregateOutputType | null
    avg: CountyAvgAggregateOutputType | null
    sum: CountySumAggregateOutputType | null
    min: CountyMinAggregateOutputType | null
    max: CountyMaxAggregateOutputType | null
  }

  type GetCountyGroupByPayload<T extends CountyGroupByArgs> = Promise<Array<
    PickArray<CountyGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CountyGroupByOutputType))]: GetScalarType<T[P], CountyGroupByOutputType[P]>
    }
  >>
    

  export type CountySelect = {
    id?: boolean
    cityId?: boolean
    name?: boolean
    city?: boolean | CityArgs
  }

  export type CountyInclude = {
    city?: boolean | CityArgs
  }

  export type CountyGetPayload<
    S extends boolean | null | undefined | CountyArgs,
    U = keyof S
      > = S extends true
        ? County
    : S extends undefined
    ? never
    : S extends CountyArgs | CountyFindManyArgs
    ?'include' extends U
    ? County  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'city'
        ? CityGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof County ?County [P]
  : 
          P extends 'city'
        ? CityGetPayload<S['select'][P]> : never
  } 
    : County
  : County


  type CountyCountArgs = Merge<
    Omit<CountyFindManyArgs, 'select' | 'include'> & {
      select?: CountyCountAggregateInputType | true
    }
  >

  export interface CountyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one County that matches the filter.
     * @param {CountyFindUniqueArgs} args - Arguments to find a County
     * @example
     * // Get one County
     * const county = await prisma.county.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'County'> extends True ? CheckSelect<T, Prisma__CountyClient<County>, Prisma__CountyClient<CountyGetPayload<T>>> : CheckSelect<T, Prisma__CountyClient<County | null >, Prisma__CountyClient<CountyGetPayload<T> | null >>

    /**
     * Find the first County that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyFindFirstArgs} args - Arguments to find a County
     * @example
     * // Get one County
     * const county = await prisma.county.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'County'> extends True ? CheckSelect<T, Prisma__CountyClient<County>, Prisma__CountyClient<CountyGetPayload<T>>> : CheckSelect<T, Prisma__CountyClient<County | null >, Prisma__CountyClient<CountyGetPayload<T> | null >>

    /**
     * Find zero or more Counties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counties
     * const counties = await prisma.county.findMany()
     * 
     * // Get first 10 Counties
     * const counties = await prisma.county.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countyWithIdOnly = await prisma.county.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountyFindManyArgs>(
      args?: SelectSubset<T, CountyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<County>>, PrismaPromise<Array<CountyGetPayload<T>>>>

    /**
     * Create a County.
     * @param {CountyCreateArgs} args - Arguments to create a County.
     * @example
     * // Create one County
     * const County = await prisma.county.create({
     *   data: {
     *     // ... data to create a County
     *   }
     * })
     * 
    **/
    create<T extends CountyCreateArgs>(
      args: SelectSubset<T, CountyCreateArgs>
    ): CheckSelect<T, Prisma__CountyClient<County>, Prisma__CountyClient<CountyGetPayload<T>>>

    /**
     * Create many Counties.
     *     @param {CountyCreateManyArgs} args - Arguments to create many Counties.
     *     @example
     *     // Create many Counties
     *     const county = await prisma.county.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountyCreateManyArgs>(
      args?: SelectSubset<T, CountyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a County.
     * @param {CountyDeleteArgs} args - Arguments to delete one County.
     * @example
     * // Delete one County
     * const County = await prisma.county.delete({
     *   where: {
     *     // ... filter to delete one County
     *   }
     * })
     * 
    **/
    delete<T extends CountyDeleteArgs>(
      args: SelectSubset<T, CountyDeleteArgs>
    ): CheckSelect<T, Prisma__CountyClient<County>, Prisma__CountyClient<CountyGetPayload<T>>>

    /**
     * Update one County.
     * @param {CountyUpdateArgs} args - Arguments to update one County.
     * @example
     * // Update one County
     * const county = await prisma.county.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountyUpdateArgs>(
      args: SelectSubset<T, CountyUpdateArgs>
    ): CheckSelect<T, Prisma__CountyClient<County>, Prisma__CountyClient<CountyGetPayload<T>>>

    /**
     * Delete zero or more Counties.
     * @param {CountyDeleteManyArgs} args - Arguments to filter Counties to delete.
     * @example
     * // Delete a few Counties
     * const { count } = await prisma.county.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountyDeleteManyArgs>(
      args?: SelectSubset<T, CountyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counties
     * const county = await prisma.county.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountyUpdateManyArgs>(
      args: SelectSubset<T, CountyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one County.
     * @param {CountyUpsertArgs} args - Arguments to update or create a County.
     * @example
     * // Update or create a County
     * const county = await prisma.county.upsert({
     *   create: {
     *     // ... data to create a County
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the County we want to update
     *   }
     * })
    **/
    upsert<T extends CountyUpsertArgs>(
      args: SelectSubset<T, CountyUpsertArgs>
    ): CheckSelect<T, Prisma__CountyClient<County>, Prisma__CountyClient<CountyGetPayload<T>>>

    /**
     * Count the number of Counties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyCountArgs} args - Arguments to filter Counties to count.
     * @example
     * // Count the number of Counties
     * const count = await prisma.county.count({
     *   where: {
     *     // ... the filter for the Counties we want to count
     *   }
     * })
    **/
    count<T extends CountyCountArgs>(
      args?: Subset<T, CountyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a County.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountyAggregateArgs>(args: Subset<T, CountyAggregateArgs>): PrismaPromise<GetCountyAggregateType<T>>

    /**
     * Group by County.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountyGroupByArgs['orderBy'] }
        : { orderBy?: CountyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountyGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for County.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    city<T extends CityArgs = {}>(args?: Subset<T, CityArgs>): CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * County findUnique
   */
  export type CountyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the County
    **/
    select?: CountySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountyInclude | null
    /**
     * Throw an Error if a County can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which County to fetch.
    **/
    where: CountyWhereUniqueInput
  }


  /**
   * County findFirst
   */
  export type CountyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the County
    **/
    select?: CountySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountyInclude | null
    /**
     * Throw an Error if a County can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which County to fetch.
    **/
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
    **/
    orderBy?: Enumerable<CountyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counties.
    **/
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counties.
    **/
    distinct?: Enumerable<CountyScalarFieldEnum>
  }


  /**
   * County findMany
   */
  export type CountyFindManyArgs = {
    /**
     * Select specific fields to fetch from the County
    **/
    select?: CountySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountyInclude | null
    /**
     * Filter, which Counties to fetch.
    **/
    where?: CountyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counties to fetch.
    **/
    orderBy?: Enumerable<CountyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Counties.
    **/
    cursor?: CountyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counties from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counties.
    **/
    skip?: number
    distinct?: Enumerable<CountyScalarFieldEnum>
  }


  /**
   * County create
   */
  export type CountyCreateArgs = {
    /**
     * Select specific fields to fetch from the County
    **/
    select?: CountySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountyInclude | null
    /**
     * The data needed to create a County.
    **/
    data: XOR<CountyCreateInput, CountyUncheckedCreateInput>
  }


  /**
   * County createMany
   */
  export type CountyCreateManyArgs = {
    data: Enumerable<CountyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * County update
   */
  export type CountyUpdateArgs = {
    /**
     * Select specific fields to fetch from the County
    **/
    select?: CountySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountyInclude | null
    /**
     * The data needed to update a County.
    **/
    data: XOR<CountyUpdateInput, CountyUncheckedUpdateInput>
    /**
     * Choose, which County to update.
    **/
    where: CountyWhereUniqueInput
  }


  /**
   * County updateMany
   */
  export type CountyUpdateManyArgs = {
    data: XOR<CountyUpdateManyMutationInput, CountyUncheckedUpdateManyInput>
    where?: CountyWhereInput
  }


  /**
   * County upsert
   */
  export type CountyUpsertArgs = {
    /**
     * Select specific fields to fetch from the County
    **/
    select?: CountySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountyInclude | null
    /**
     * The filter to search for the County to update in case it exists.
    **/
    where: CountyWhereUniqueInput
    /**
     * In case the County found by the `where` argument doesn't exist, create a new County with this data.
    **/
    create: XOR<CountyCreateInput, CountyUncheckedCreateInput>
    /**
     * In case the County was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CountyUpdateInput, CountyUncheckedUpdateInput>
  }


  /**
   * County delete
   */
  export type CountyDeleteArgs = {
    /**
     * Select specific fields to fetch from the County
    **/
    select?: CountySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountyInclude | null
    /**
     * Filter which County to delete.
    **/
    where: CountyWhereUniqueInput
  }


  /**
   * County deleteMany
   */
  export type CountyDeleteManyArgs = {
    where?: CountyWhereInput
  }


  /**
   * County without action
   */
  export type CountyArgs = {
    /**
     * Select specific fields to fetch from the County
    **/
    select?: CountySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountyInclude | null
  }



  /**
   * Model City
   */


  export type AggregateCity = {
    count: CityCountAggregateOutputType | null
    avg: CityAvgAggregateOutputType | null
    sum: CitySumAggregateOutputType | null
    min: CityMinAggregateOutputType | null
    max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number | null
    stateId: number | null
  }

  export type CitySumAggregateOutputType = {
    id: number | null
    stateId: number | null
  }

  export type CityMinAggregateOutputType = {
    id: number | null
    stateId: number | null
    name: string | null
  }

  export type CityMaxAggregateOutputType = {
    id: number | null
    stateId: number | null
    name: string | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    stateId: number
    name: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
    stateId?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
    stateId?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    stateId?: true
    name?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    stateId?: true
    name?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    stateId?: true
    name?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which City to aggregate.
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
    **/
    orderBy?: Enumerable<CityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
    [P in keyof T & keyof AggregateCity]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }


    
    
  export type CityGroupByArgs = {
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByInput>
    by: Array<CityScalarFieldEnum>
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CityCountAggregateInputType | true
    avg?: CityAvgAggregateInputType
    sum?: CitySumAggregateInputType
    min?: CityMinAggregateInputType
    max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    id: number
    stateId: number
    name: string
    count: CityCountAggregateOutputType | null
    avg: CityAvgAggregateOutputType | null
    sum: CitySumAggregateOutputType | null
    min: CityMinAggregateOutputType | null
    max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Promise<Array<
    PickArray<CityGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CityGroupByOutputType))]: GetScalarType<T[P], CityGroupByOutputType[P]>
    }
  >>
    

  export type CitySelect = {
    id?: boolean
    stateId?: boolean
    name?: boolean
    state?: boolean | StateArgs
    counties?: boolean | CountyFindManyArgs
  }

  export type CityInclude = {
    state?: boolean | StateArgs
    counties?: boolean | CountyFindManyArgs
  }

  export type CityGetPayload<
    S extends boolean | null | undefined | CityArgs,
    U = keyof S
      > = S extends true
        ? City
    : S extends undefined
    ? never
    : S extends CityArgs | CityFindManyArgs
    ?'include' extends U
    ? City  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'state'
        ? StateGetPayload<S['include'][P]> :
        P extends 'counties'
        ? Array < CountyGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof City ?City [P]
  : 
          P extends 'state'
        ? StateGetPayload<S['select'][P]> :
        P extends 'counties'
        ? Array < CountyGetPayload<S['select'][P]>>  : never
  } 
    : City
  : City


  type CityCountArgs = Merge<
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }
  >

  export interface CityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs>(
      args?: SelectSubset<T, CityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs>(
      args: SelectSubset<T, CityCreateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs>(
      args?: SelectSubset<T, CityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs>(
      args: SelectSubset<T, CityDeleteArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs>(
      args: SelectSubset<T, CityUpdateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs>(
      args?: SelectSubset<T, CityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs>(
      args: SelectSubset<T, CityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs>(
      args: SelectSubset<T, CityUpsertArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    state<T extends StateArgs = {}>(args?: Subset<T, StateArgs>): CheckSelect<T, Prisma__StateClient<State | null >, Prisma__StateClient<StateGetPayload<T> | null >>;

    counties<T extends CountyFindManyArgs = {}>(args?: Subset<T, CountyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<County>>, PrismaPromise<Array<CountyGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * City findUnique
   */
  export type CityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * Throw an Error if a City can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which City to fetch.
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City findFirst
   */
  export type CityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * Throw an Error if a City can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which City to fetch.
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
    **/
    orderBy?: Enumerable<CityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
    **/
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City findMany
   */
  export type CityFindManyArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * Filter, which Cities to fetch.
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
    **/
    orderBy?: Enumerable<CityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
    **/
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City create
   */
  export type CityCreateArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * The data needed to create a City.
    **/
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs = {
    data: Enumerable<CityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * The data needed to update a City.
    **/
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs = {
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * The filter to search for the City to update in case it exists.
    **/
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
    **/
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * Filter which City to delete.
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs = {
    where?: CityWhereInput
  }


  /**
   * City without action
   */
  export type CityArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
  }



  /**
   * Model State
   */


  export type AggregateState = {
    count: StateCountAggregateOutputType | null
    avg: StateAvgAggregateOutputType | null
    sum: StateSumAggregateOutputType | null
    min: StateMinAggregateOutputType | null
    max: StateMaxAggregateOutputType | null
  }

  export type StateAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type StateSumAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type StateMinAggregateOutputType = {
    id: number | null
    countryId: number | null
    name: string | null
  }

  export type StateMaxAggregateOutputType = {
    id: number | null
    countryId: number | null
    name: string | null
  }

  export type StateCountAggregateOutputType = {
    id: number
    countryId: number
    name: number
    _all: number
  }


  export type StateAvgAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type StateSumAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type StateMinAggregateInputType = {
    id?: true
    countryId?: true
    name?: true
  }

  export type StateMaxAggregateInputType = {
    id?: true
    countryId?: true
    name?: true
  }

  export type StateCountAggregateInputType = {
    id?: true
    countryId?: true
    name?: true
    _all?: true
  }

  export type StateAggregateArgs = {
    /**
     * Filter which State to aggregate.
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
    **/
    orderBy?: Enumerable<StateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: StateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: StateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
    [P in keyof T & keyof AggregateState]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }


    
    
  export type StateGroupByArgs = {
    where?: StateWhereInput
    orderBy?: Enumerable<StateOrderByInput>
    by: Array<StateScalarFieldEnum>
    having?: StateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: StateCountAggregateInputType | true
    avg?: StateAvgAggregateInputType
    sum?: StateSumAggregateInputType
    min?: StateMinAggregateInputType
    max?: StateMaxAggregateInputType
  }


  export type StateGroupByOutputType = {
    id: number
    countryId: number
    name: string
    count: StateCountAggregateOutputType | null
    avg: StateAvgAggregateOutputType | null
    sum: StateSumAggregateOutputType | null
    min: StateMinAggregateOutputType | null
    max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends StateGroupByArgs> = Promise<Array<
    PickArray<StateGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof StateGroupByOutputType))]: GetScalarType<T[P], StateGroupByOutputType[P]>
    }
  >>
    

  export type StateSelect = {
    id?: boolean
    countryId?: boolean
    name?: boolean
    cities?: boolean | CityFindManyArgs
    country?: boolean | CountryArgs
  }

  export type StateInclude = {
    cities?: boolean | CityFindManyArgs
    country?: boolean | CountryArgs
  }

  export type StateGetPayload<
    S extends boolean | null | undefined | StateArgs,
    U = keyof S
      > = S extends true
        ? State
    : S extends undefined
    ? never
    : S extends StateArgs | StateFindManyArgs
    ?'include' extends U
    ? State  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'cities'
        ? Array < CityGetPayload<S['include'][P]>>  :
        P extends 'country'
        ? CountryGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof State ?State [P]
  : 
          P extends 'cities'
        ? Array < CityGetPayload<S['select'][P]>>  :
        P extends 'country'
        ? CountryGetPayload<S['select'][P]> : never
  } 
    : State
  : State


  type StateCountArgs = Merge<
    Omit<StateFindManyArgs, 'select' | 'include'> & {
      select?: StateCountAggregateInputType | true
    }
  >

  export interface StateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one State that matches the filter.
     * @param {StateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'State'> extends True ? CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>> : CheckSelect<T, Prisma__StateClient<State | null >, Prisma__StateClient<StateGetPayload<T> | null >>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'State'> extends True ? CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>> : CheckSelect<T, Prisma__StateClient<State | null >, Prisma__StateClient<StateGetPayload<T> | null >>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateWithIdOnly = await prisma.state.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StateFindManyArgs>(
      args?: SelectSubset<T, StateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<State>>, PrismaPromise<Array<StateGetPayload<T>>>>

    /**
     * Create a State.
     * @param {StateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
    **/
    create<T extends StateCreateArgs>(
      args: SelectSubset<T, StateCreateArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Create many States.
     *     @param {StateCreateManyArgs} args - Arguments to create many States.
     *     @example
     *     // Create many States
     *     const state = await prisma.state.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StateCreateManyArgs>(
      args?: SelectSubset<T, StateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a State.
     * @param {StateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
    **/
    delete<T extends StateDeleteArgs>(
      args: SelectSubset<T, StateDeleteArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Update one State.
     * @param {StateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StateUpdateArgs>(
      args: SelectSubset<T, StateUpdateArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Delete zero or more States.
     * @param {StateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StateDeleteManyArgs>(
      args?: SelectSubset<T, StateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StateUpdateManyArgs>(
      args: SelectSubset<T, StateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one State.
     * @param {StateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
    **/
    upsert<T extends StateUpsertArgs>(
      args: SelectSubset<T, StateUpsertArgs>
    ): CheckSelect<T, Prisma__StateClient<State>, Prisma__StateClient<StateGetPayload<T>>>

    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StateCountArgs>(
      args?: Subset<T, StateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateGroupByArgs['orderBy'] }
        : { orderBy?: StateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for State.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cities<T extends CityFindManyArgs = {}>(args?: Subset<T, CityFindManyArgs>): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>;

    country<T extends CountryArgs = {}>(args?: Subset<T, CountryArgs>): CheckSelect<T, Prisma__CountryClient<Country | null >, Prisma__CountryClient<CountryGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * State findUnique
   */
  export type StateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the State
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StateInclude | null
    /**
     * Throw an Error if a State can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which State to fetch.
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State findFirst
   */
  export type StateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the State
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StateInclude | null
    /**
     * Throw an Error if a State can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which State to fetch.
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
    **/
    orderBy?: Enumerable<StateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
    **/
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State findMany
   */
  export type StateFindManyArgs = {
    /**
     * Select specific fields to fetch from the State
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StateInclude | null
    /**
     * Filter, which States to fetch.
    **/
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
    **/
    orderBy?: Enumerable<StateOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
    **/
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
    **/
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State create
   */
  export type StateCreateArgs = {
    /**
     * Select specific fields to fetch from the State
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StateInclude | null
    /**
     * The data needed to create a State.
    **/
    data: XOR<StateCreateInput, StateUncheckedCreateInput>
  }


  /**
   * State createMany
   */
  export type StateCreateManyArgs = {
    data: Enumerable<StateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * State update
   */
  export type StateUpdateArgs = {
    /**
     * Select specific fields to fetch from the State
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StateInclude | null
    /**
     * The data needed to update a State.
    **/
    data: XOR<StateUpdateInput, StateUncheckedUpdateInput>
    /**
     * Choose, which State to update.
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State updateMany
   */
  export type StateUpdateManyArgs = {
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyInput>
    where?: StateWhereInput
  }


  /**
   * State upsert
   */
  export type StateUpsertArgs = {
    /**
     * Select specific fields to fetch from the State
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StateInclude | null
    /**
     * The filter to search for the State to update in case it exists.
    **/
    where: StateWhereUniqueInput
    /**
     * In case the State found by the `where` argument doesn't exist, create a new State with this data.
    **/
    create: XOR<StateCreateInput, StateUncheckedCreateInput>
    /**
     * In case the State was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<StateUpdateInput, StateUncheckedUpdateInput>
  }


  /**
   * State delete
   */
  export type StateDeleteArgs = {
    /**
     * Select specific fields to fetch from the State
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StateInclude | null
    /**
     * Filter which State to delete.
    **/
    where: StateWhereUniqueInput
  }


  /**
   * State deleteMany
   */
  export type StateDeleteManyArgs = {
    where?: StateWhereInput
  }


  /**
   * State without action
   */
  export type StateArgs = {
    /**
     * Select specific fields to fetch from the State
    **/
    select?: StateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: StateInclude | null
  }



  /**
   * Model Country
   */


  export type AggregateCountry = {
    count: CountryCountAggregateOutputType | null
    avg: CountryAvgAggregateOutputType | null
    sum: CountrySumAggregateOutputType | null
    min: CountryMinAggregateOutputType | null
    max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
    currencyId: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
    currencyId: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    currencyId: number | null
    name: string | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    currencyId: number | null
    name: string | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    currencyId: number
    name: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
    currencyId?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
    currencyId?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    currencyId?: true
    name?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    currencyId?: true
    name?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    currencyId?: true
    name?: true
    _all?: true
  }

  export type CountryAggregateArgs = {
    /**
     * Filter which Country to aggregate.
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
    **/
    orderBy?: Enumerable<CountryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
    [P in keyof T & keyof AggregateCountry]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }


    
    
  export type CountryGroupByArgs = {
    where?: CountryWhereInput
    orderBy?: Enumerable<CountryOrderByInput>
    by: Array<CountryScalarFieldEnum>
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CountryCountAggregateInputType | true
    avg?: CountryAvgAggregateInputType
    sum?: CountrySumAggregateInputType
    min?: CountryMinAggregateInputType
    max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    id: number
    currencyId: number
    name: string
    count: CountryCountAggregateOutputType | null
    avg: CountryAvgAggregateOutputType | null
    sum: CountrySumAggregateOutputType | null
    min: CountryMinAggregateOutputType | null
    max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Promise<Array<
    PickArray<CountryGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CountryGroupByOutputType))]: GetScalarType<T[P], CountryGroupByOutputType[P]>
    }
  >>
    

  export type CountrySelect = {
    id?: boolean
    currencyId?: boolean
    name?: boolean
    currency?: boolean | CurrencyArgs
    states?: boolean | StateFindManyArgs
  }

  export type CountryInclude = {
    currency?: boolean | CurrencyArgs
    states?: boolean | StateFindManyArgs
  }

  export type CountryGetPayload<
    S extends boolean | null | undefined | CountryArgs,
    U = keyof S
      > = S extends true
        ? Country
    : S extends undefined
    ? never
    : S extends CountryArgs | CountryFindManyArgs
    ?'include' extends U
    ? Country  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'currency'
        ? CurrencyGetPayload<S['include'][P]> :
        P extends 'states'
        ? Array < StateGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Country ?Country [P]
  : 
          P extends 'currency'
        ? CurrencyGetPayload<S['select'][P]> :
        P extends 'states'
        ? Array < StateGetPayload<S['select'][P]>>  : never
  } 
    : Country
  : Country


  type CountryCountArgs = Merge<
    Omit<CountryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }
  >

  export interface CountryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null >, Prisma__CountryClient<CountryGetPayload<T> | null >>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null >, Prisma__CountryClient<CountryGetPayload<T> | null >>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs>(
      args?: SelectSubset<T, CountryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Country>>, PrismaPromise<Array<CountryGetPayload<T>>>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs>(
      args: SelectSubset<T, CountryCreateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs>(
      args?: SelectSubset<T, CountryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs>(
      args: SelectSubset<T, CountryDeleteArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs>(
      args: SelectSubset<T, CountryUpdateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs>(
      args?: SelectSubset<T, CountryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs>(
      args: SelectSubset<T, CountryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs>(
      args: SelectSubset<T, CountryUpsertArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    currency<T extends CurrencyArgs = {}>(args?: Subset<T, CurrencyArgs>): CheckSelect<T, Prisma__CurrencyClient<Currency | null >, Prisma__CurrencyClient<CurrencyGetPayload<T> | null >>;

    states<T extends StateFindManyArgs = {}>(args?: Subset<T, StateFindManyArgs>): CheckSelect<T, PrismaPromise<Array<State>>, PrismaPromise<Array<StateGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Country
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountryInclude | null
    /**
     * Throw an Error if a Country can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Country to fetch.
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Country
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountryInclude | null
    /**
     * Throw an Error if a Country can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Country to fetch.
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
    **/
    orderBy?: Enumerable<CountryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
    **/
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country findMany
   */
  export type CountryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Country
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Countries to fetch.
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
    **/
    orderBy?: Enumerable<CountryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
    **/
    skip?: number
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country create
   */
  export type CountryCreateArgs = {
    /**
     * Select specific fields to fetch from the Country
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountryInclude | null
    /**
     * The data needed to create a Country.
    **/
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs = {
    data: Enumerable<CountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Country
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountryInclude | null
    /**
     * The data needed to update a Country.
    **/
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs = {
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Country
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountryInclude | null
    /**
     * The filter to search for the Country to update in case it exists.
    **/
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
    **/
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Country
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountryInclude | null
    /**
     * Filter which Country to delete.
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs = {
    where?: CountryWhereInput
  }


  /**
   * Country without action
   */
  export type CountryArgs = {
    /**
     * Select specific fields to fetch from the Country
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CountryInclude | null
  }



  /**
   * Model Currency
   */


  export type AggregateCurrency = {
    count: CurrencyCountAggregateOutputType | null
    avg: CurrencyAvgAggregateOutputType | null
    sum: CurrencySumAggregateOutputType | null
    min: CurrencyMinAggregateOutputType | null
    max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    id: number | null
    exchangeRate: number | null
  }

  export type CurrencySumAggregateOutputType = {
    id: number | null
    exchangeRate: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: number | null
    code: string | null
    exchangeRate: number | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: number | null
    code: string | null
    exchangeRate: number | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    code: number
    exchangeRate: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    id?: true
    exchangeRate?: true
  }

  export type CurrencySumAggregateInputType = {
    id?: true
    exchangeRate?: true
  }

  export type CurrencyMinAggregateInputType = {
    id?: true
    code?: true
    exchangeRate?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    code?: true
    exchangeRate?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    code?: true
    exchangeRate?: true
    _all?: true
  }

  export type CurrencyAggregateArgs = {
    /**
     * Filter which Currency to aggregate.
    **/
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
    **/
    orderBy?: Enumerable<CurrencyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
    [P in keyof T & keyof AggregateCurrency]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }


    
    
  export type CurrencyGroupByArgs = {
    where?: CurrencyWhereInput
    orderBy?: Enumerable<CurrencyOrderByInput>
    by: Array<CurrencyScalarFieldEnum>
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CurrencyCountAggregateInputType | true
    avg?: CurrencyAvgAggregateInputType
    sum?: CurrencySumAggregateInputType
    min?: CurrencyMinAggregateInputType
    max?: CurrencyMaxAggregateInputType
  }


  export type CurrencyGroupByOutputType = {
    id: number
    code: string
    exchangeRate: number
    count: CurrencyCountAggregateOutputType | null
    avg: CurrencyAvgAggregateOutputType | null
    sum: CurrencySumAggregateOutputType | null
    min: CurrencyMinAggregateOutputType | null
    max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Promise<Array<
    PickArray<CurrencyGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: GetScalarType<T[P], CurrencyGroupByOutputType[P]>
    }
  >>
    

  export type CurrencySelect = {
    id?: boolean
    code?: boolean
    exchangeRate?: boolean
    Payment?: boolean | PaymentFindManyArgs
    countries?: boolean | CountryFindManyArgs
  }

  export type CurrencyInclude = {
    Payment?: boolean | PaymentFindManyArgs
    countries?: boolean | CountryFindManyArgs
  }

  export type CurrencyGetPayload<
    S extends boolean | null | undefined | CurrencyArgs,
    U = keyof S
      > = S extends true
        ? Currency
    : S extends undefined
    ? never
    : S extends CurrencyArgs | CurrencyFindManyArgs
    ?'include' extends U
    ? Currency  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Payment'
        ? Array < PaymentGetPayload<S['include'][P]>>  :
        P extends 'countries'
        ? Array < CountryGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Currency ?Currency [P]
  : 
          P extends 'Payment'
        ? Array < PaymentGetPayload<S['select'][P]>>  :
        P extends 'countries'
        ? Array < CountryGetPayload<S['select'][P]>>  : never
  } 
    : Currency
  : Currency


  type CurrencyCountArgs = Merge<
    Omit<CurrencyFindManyArgs, 'select' | 'include'> & {
      select?: CurrencyCountAggregateInputType | true
    }
  >

  export interface CurrencyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CurrencyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CurrencyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Currency'> extends True ? CheckSelect<T, Prisma__CurrencyClient<Currency>, Prisma__CurrencyClient<CurrencyGetPayload<T>>> : CheckSelect<T, Prisma__CurrencyClient<Currency | null >, Prisma__CurrencyClient<CurrencyGetPayload<T> | null >>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CurrencyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CurrencyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Currency'> extends True ? CheckSelect<T, Prisma__CurrencyClient<Currency>, Prisma__CurrencyClient<CurrencyGetPayload<T>>> : CheckSelect<T, Prisma__CurrencyClient<Currency | null >, Prisma__CurrencyClient<CurrencyGetPayload<T> | null >>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CurrencyFindManyArgs>(
      args?: SelectSubset<T, CurrencyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Currency>>, PrismaPromise<Array<CurrencyGetPayload<T>>>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
    **/
    create<T extends CurrencyCreateArgs>(
      args: SelectSubset<T, CurrencyCreateArgs>
    ): CheckSelect<T, Prisma__CurrencyClient<Currency>, Prisma__CurrencyClient<CurrencyGetPayload<T>>>

    /**
     * Create many Currencies.
     *     @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     *     @example
     *     // Create many Currencies
     *     const currency = await prisma.currency.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CurrencyCreateManyArgs>(
      args?: SelectSubset<T, CurrencyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
    **/
    delete<T extends CurrencyDeleteArgs>(
      args: SelectSubset<T, CurrencyDeleteArgs>
    ): CheckSelect<T, Prisma__CurrencyClient<Currency>, Prisma__CurrencyClient<CurrencyGetPayload<T>>>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CurrencyUpdateArgs>(
      args: SelectSubset<T, CurrencyUpdateArgs>
    ): CheckSelect<T, Prisma__CurrencyClient<Currency>, Prisma__CurrencyClient<CurrencyGetPayload<T>>>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CurrencyDeleteManyArgs>(
      args?: SelectSubset<T, CurrencyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CurrencyUpdateManyArgs>(
      args: SelectSubset<T, CurrencyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
    **/
    upsert<T extends CurrencyUpsertArgs>(
      args: SelectSubset<T, CurrencyUpsertArgs>
    ): CheckSelect<T, Prisma__CurrencyClient<Currency>, Prisma__CurrencyClient<CurrencyGetPayload<T>>>

    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CurrencyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Payment<T extends PaymentFindManyArgs = {}>(args?: Subset<T, PaymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Payment>>, PrismaPromise<Array<PaymentGetPayload<T>>>>;

    countries<T extends CountryFindManyArgs = {}>(args?: Subset<T, CountryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Country>>, PrismaPromise<Array<CountryGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Currency
    **/
    select?: CurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CurrencyInclude | null
    /**
     * Throw an Error if a Currency can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Currency to fetch.
    **/
    where: CurrencyWhereUniqueInput
  }


  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Currency
    **/
    select?: CurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CurrencyInclude | null
    /**
     * Throw an Error if a Currency can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Currency to fetch.
    **/
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
    **/
    orderBy?: Enumerable<CurrencyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
    **/
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
    **/
    distinct?: Enumerable<CurrencyScalarFieldEnum>
  }


  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Currency
    **/
    select?: CurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CurrencyInclude | null
    /**
     * Filter, which Currencies to fetch.
    **/
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
    **/
    orderBy?: Enumerable<CurrencyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
    **/
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
    **/
    skip?: number
    distinct?: Enumerable<CurrencyScalarFieldEnum>
  }


  /**
   * Currency create
   */
  export type CurrencyCreateArgs = {
    /**
     * Select specific fields to fetch from the Currency
    **/
    select?: CurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CurrencyInclude | null
    /**
     * The data needed to create a Currency.
    **/
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }


  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs = {
    data: Enumerable<CurrencyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Currency update
   */
  export type CurrencyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Currency
    **/
    select?: CurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CurrencyInclude | null
    /**
     * The data needed to update a Currency.
    **/
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
    **/
    where: CurrencyWhereUniqueInput
  }


  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs = {
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    where?: CurrencyWhereInput
  }


  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Currency
    **/
    select?: CurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CurrencyInclude | null
    /**
     * The filter to search for the Currency to update in case it exists.
    **/
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
    **/
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }


  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Currency
    **/
    select?: CurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CurrencyInclude | null
    /**
     * Filter which Currency to delete.
    **/
    where: CurrencyWhereUniqueInput
  }


  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs = {
    where?: CurrencyWhereInput
  }


  /**
   * Currency without action
   */
  export type CurrencyArgs = {
    /**
     * Select specific fields to fetch from the Currency
    **/
    select?: CurrencySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CurrencyInclude | null
  }



  /**
   * Model Payment
   */


  export type AggregatePayment = {
    count: PaymentCountAggregateOutputType | null
    avg: PaymentAvgAggregateOutputType | null
    sum: PaymentSumAggregateOutputType | null
    min: PaymentMinAggregateOutputType | null
    max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    currencyId: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    currencyId: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    currencyId: number | null
    method: string | null
    status: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    currencyId: number | null
    method: string | null
    status: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    currencyId: number
    method: number
    status: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    currencyId?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    currencyId?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    currencyId?: true
    method?: true
    status?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    currencyId?: true
    method?: true
    status?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    currencyId?: true
    method?: true
    status?: true
    _all?: true
  }

  export type PaymentAggregateArgs = {
    /**
     * Filter which Payment to aggregate.
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
    **/
    orderBy?: Enumerable<PaymentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
    [P in keyof T & keyof AggregatePayment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }


    
    
  export type PaymentGroupByArgs = {
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByInput>
    by: Array<PaymentScalarFieldEnum>
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: PaymentCountAggregateInputType | true
    avg?: PaymentAvgAggregateInputType
    sum?: PaymentSumAggregateInputType
    min?: PaymentMinAggregateInputType
    max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: number
    currencyId: number
    method: string
    status: string
    count: PaymentCountAggregateOutputType | null
    avg: PaymentAvgAggregateOutputType | null
    sum: PaymentSumAggregateOutputType | null
    min: PaymentMinAggregateOutputType | null
    max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Promise<Array<
    PickArray<PaymentGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: GetScalarType<T[P], PaymentGroupByOutputType[P]>
    }
  >>
    

  export type PaymentSelect = {
    id?: boolean
    currencyId?: boolean
    method?: boolean
    status?: boolean
    currency?: boolean | CurrencyArgs
  }

  export type PaymentInclude = {
    currency?: boolean | CurrencyArgs
  }

  export type PaymentGetPayload<
    S extends boolean | null | undefined | PaymentArgs,
    U = keyof S
      > = S extends true
        ? Payment
    : S extends undefined
    ? never
    : S extends PaymentArgs | PaymentFindManyArgs
    ?'include' extends U
    ? Payment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'currency'
        ? CurrencyGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Payment ?Payment [P]
  : 
          P extends 'currency'
        ? CurrencyGetPayload<S['select'][P]> : never
  } 
    : Payment
  : Payment


  type PaymentCountArgs = Merge<
    Omit<PaymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }
  >

  export interface PaymentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Payment'> extends True ? CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>> : CheckSelect<T, Prisma__PaymentClient<Payment | null >, Prisma__PaymentClient<PaymentGetPayload<T> | null >>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Payment'> extends True ? CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>> : CheckSelect<T, Prisma__PaymentClient<Payment | null >, Prisma__PaymentClient<PaymentGetPayload<T> | null >>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs>(
      args?: SelectSubset<T, PaymentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Payment>>, PrismaPromise<Array<PaymentGetPayload<T>>>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs>(
      args: SelectSubset<T, PaymentCreateArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs>(
      args?: SelectSubset<T, PaymentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs>(
      args: SelectSubset<T, PaymentDeleteArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs>(
      args: SelectSubset<T, PaymentUpdateArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs>(
      args?: SelectSubset<T, PaymentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs>(
      args: SelectSubset<T, PaymentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs>(
      args: SelectSubset<T, PaymentUpsertArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    currency<T extends CurrencyArgs = {}>(args?: Subset<T, CurrencyArgs>): CheckSelect<T, Prisma__CurrencyClient<Currency | null >, Prisma__CurrencyClient<CurrencyGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Payment
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PaymentInclude | null
    /**
     * Throw an Error if a Payment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Payment to fetch.
    **/
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Payment
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PaymentInclude | null
    /**
     * Throw an Error if a Payment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Payment to fetch.
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
    **/
    orderBy?: Enumerable<PaymentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
    **/
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Payment
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PaymentInclude | null
    /**
     * Filter, which Payments to fetch.
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
    **/
    orderBy?: Enumerable<PaymentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
    **/
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs = {
    /**
     * Select specific fields to fetch from the Payment
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PaymentInclude | null
    /**
     * The data needed to create a Payment.
    **/
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs = {
    data: Enumerable<PaymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Payment
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PaymentInclude | null
    /**
     * The data needed to update a Payment.
    **/
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
    **/
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs = {
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Payment
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PaymentInclude | null
    /**
     * The filter to search for the Payment to update in case it exists.
    **/
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
    **/
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Payment
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PaymentInclude | null
    /**
     * Filter which Payment to delete.
    **/
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs = {
    where?: PaymentWhereInput
  }


  /**
   * Payment without action
   */
  export type PaymentArgs = {
    /**
     * Select specific fields to fetch from the Payment
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PaymentInclude | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    count: CategoryCountAggregateOutputType | null
    avg: CategoryAvgAggregateOutputType | null
    sum: CategorySumAggregateOutputType | null
    min: CategoryMinAggregateOutputType | null
    max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    maxImgs: number | null
    postValidityIntervalInDays: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    parentId: number | null
    maxImgs: number | null
    postValidityIntervalInDays: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    parentId: number | null
    name: string | null
    maxImgs: number | null
    postValidityIntervalInDays: number | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    parentId: number | null
    name: string | null
    maxImgs: number | null
    postValidityIntervalInDays: number | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    parentId: number
    name: number
    maxImgs: number
    postValidityIntervalInDays: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    parentId?: true
    maxImgs?: true
    postValidityIntervalInDays?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    parentId?: true
    maxImgs?: true
    postValidityIntervalInDays?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    parentId?: true
    name?: true
    maxImgs?: true
    postValidityIntervalInDays?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    parentId?: true
    name?: true
    maxImgs?: true
    postValidityIntervalInDays?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    parentId?: true
    name?: true
    maxImgs?: true
    postValidityIntervalInDays?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
    **/
    orderBy?: Enumerable<CategoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
    [P in keyof T & keyof AggregateCategory]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }


    
    
  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByInput>
    by: Array<CategoryScalarFieldEnum>
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CategoryCountAggregateInputType | true
    avg?: CategoryAvgAggregateInputType
    sum?: CategorySumAggregateInputType
    min?: CategoryMinAggregateInputType
    max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: number
    parentId: number | null
    name: string
    maxImgs: number
    postValidityIntervalInDays: number | null
    count: CategoryCountAggregateOutputType | null
    avg: CategoryAvgAggregateOutputType | null
    sum: CategorySumAggregateOutputType | null
    min: CategoryMinAggregateOutputType | null
    max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Promise<Array<
    PickArray<CategoryGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: GetScalarType<T[P], CategoryGroupByOutputType[P]>
    }
  >>
    

  export type CategorySelect = {
    id?: boolean
    parentId?: boolean
    name?: boolean
    maxImgs?: boolean
    postValidityIntervalInDays?: boolean
    children?: boolean | CategoryFindManyArgs
    parent?: boolean | CategoryArgs
    posts?: boolean | PostFindManyArgs
    properties?: boolean | PropertyFindManyArgs
  }

  export type CategoryInclude = {
    children?: boolean | CategoryFindManyArgs
    parent?: boolean | CategoryArgs
    posts?: boolean | PostFindManyArgs
    properties?: boolean | PropertyFindManyArgs
  }

  export type CategoryGetPayload<
    S extends boolean | null | undefined | CategoryArgs,
    U = keyof S
      > = S extends true
        ? Category
    : S extends undefined
    ? never
    : S extends CategoryArgs | CategoryFindManyArgs
    ?'include' extends U
    ? Category  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'children'
        ? Array < CategoryGetPayload<S['include'][P]>>  :
        P extends 'parent'
        ? CategoryGetPayload<S['include'][P]> | null :
        P extends 'posts'
        ? Array < PostGetPayload<S['include'][P]>>  :
        P extends 'properties'
        ? Array < PropertyGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Category ?Category [P]
  : 
          P extends 'children'
        ? Array < CategoryGetPayload<S['select'][P]>>  :
        P extends 'parent'
        ? CategoryGetPayload<S['select'][P]> | null :
        P extends 'posts'
        ? Array < PostGetPayload<S['select'][P]>>  :
        P extends 'properties'
        ? Array < PropertyGetPayload<S['select'][P]>>  : never
  } 
    : Category
  : Category


  type CategoryCountArgs = Merge<
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }
  >

  export interface CategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    children<T extends CategoryFindManyArgs = {}>(args?: Subset<T, CategoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>;

    parent<T extends CategoryArgs = {}>(args?: Subset<T, CategoryArgs>): CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>;

    posts<T extends PostFindManyArgs = {}>(args?: Subset<T, PostFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Post>>, PrismaPromise<Array<PostGetPayload<T>>>>;

    properties<T extends PropertyFindManyArgs = {}>(args?: Subset<T, PropertyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Property>>, PrismaPromise<Array<PropertyGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * Throw an Error if a Category can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * Throw an Error if a Category can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
    **/
    orderBy?: Enumerable<CategoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
    **/
    orderBy?: Enumerable<CategoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
    **/
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
    **/
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
    **/
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
    **/
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
    **/
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    where?: CategoryWhereInput
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
  }



  /**
   * Model Property
   */


  export type AggregateProperty = {
    count: PropertyCountAggregateOutputType | null
    avg: PropertyAvgAggregateOutputType | null
    sum: PropertySumAggregateOutputType | null
    min: PropertyMinAggregateOutputType | null
    max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    screenControlId: number | null
  }

  export type PropertySumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    screenControlId: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: number | null
    categoryId: number | null
    name: string | null
    unit: string | null
    isMandatory: boolean | null
    screenControlId: number | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: number | null
    categoryId: number | null
    name: string | null
    unit: string | null
    isMandatory: boolean | null
    screenControlId: number | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    unit: number
    isMandatory: number
    screenControlId: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    id?: true
    categoryId?: true
    screenControlId?: true
  }

  export type PropertySumAggregateInputType = {
    id?: true
    categoryId?: true
    screenControlId?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    unit?: true
    isMandatory?: true
    screenControlId?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    unit?: true
    isMandatory?: true
    screenControlId?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    unit?: true
    isMandatory?: true
    screenControlId?: true
    _all?: true
  }

  export type PropertyAggregateArgs = {
    /**
     * Filter which Property to aggregate.
    **/
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
    **/
    orderBy?: Enumerable<PropertyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
    [P in keyof T & keyof AggregateProperty]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }


    
    
  export type PropertyGroupByArgs = {
    where?: PropertyWhereInput
    orderBy?: Enumerable<PropertyOrderByInput>
    by: Array<PropertyScalarFieldEnum>
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: PropertyCountAggregateInputType | true
    avg?: PropertyAvgAggregateInputType
    sum?: PropertySumAggregateInputType
    min?: PropertyMinAggregateInputType
    max?: PropertyMaxAggregateInputType
  }


  export type PropertyGroupByOutputType = {
    id: number
    categoryId: number
    name: string
    unit: string
    isMandatory: boolean
    screenControlId: number
    count: PropertyCountAggregateOutputType | null
    avg: PropertyAvgAggregateOutputType | null
    sum: PropertySumAggregateOutputType | null
    min: PropertyMinAggregateOutputType | null
    max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Promise<Array<
    PickArray<PropertyGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: GetScalarType<T[P], PropertyGroupByOutputType[P]>
    }
  >>
    

  export type PropertySelect = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    unit?: boolean
    isMandatory?: boolean
    values?: boolean | PossibleValuesFindManyArgs
    screenControlId?: boolean
    screenControl?: boolean | ScreenControlArgs
    Category?: boolean | CategoryArgs
  }

  export type PropertyInclude = {
    values?: boolean | PossibleValuesFindManyArgs
    screenControl?: boolean | ScreenControlArgs
    Category?: boolean | CategoryArgs
  }

  export type PropertyGetPayload<
    S extends boolean | null | undefined | PropertyArgs,
    U = keyof S
      > = S extends true
        ? Property
    : S extends undefined
    ? never
    : S extends PropertyArgs | PropertyFindManyArgs
    ?'include' extends U
    ? Property  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'values'
        ? Array < PossibleValuesGetPayload<S['include'][P]>>  :
        P extends 'screenControl'
        ? ScreenControlGetPayload<S['include'][P]> :
        P extends 'Category'
        ? CategoryGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Property ?Property [P]
  : 
          P extends 'values'
        ? Array < PossibleValuesGetPayload<S['select'][P]>>  :
        P extends 'screenControl'
        ? ScreenControlGetPayload<S['select'][P]> :
        P extends 'Category'
        ? CategoryGetPayload<S['select'][P]> | null : never
  } 
    : Property
  : Property


  type PropertyCountArgs = Merge<
    Omit<PropertyFindManyArgs, 'select' | 'include'> & {
      select?: PropertyCountAggregateInputType | true
    }
  >

  export interface PropertyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PropertyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Property'> extends True ? CheckSelect<T, Prisma__PropertyClient<Property>, Prisma__PropertyClient<PropertyGetPayload<T>>> : CheckSelect<T, Prisma__PropertyClient<Property | null >, Prisma__PropertyClient<PropertyGetPayload<T> | null >>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PropertyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Property'> extends True ? CheckSelect<T, Prisma__PropertyClient<Property>, Prisma__PropertyClient<PropertyGetPayload<T>>> : CheckSelect<T, Prisma__PropertyClient<Property | null >, Prisma__PropertyClient<PropertyGetPayload<T> | null >>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyFindManyArgs>(
      args?: SelectSubset<T, PropertyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Property>>, PrismaPromise<Array<PropertyGetPayload<T>>>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
    **/
    create<T extends PropertyCreateArgs>(
      args: SelectSubset<T, PropertyCreateArgs>
    ): CheckSelect<T, Prisma__PropertyClient<Property>, Prisma__PropertyClient<PropertyGetPayload<T>>>

    /**
     * Create many Properties.
     *     @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     *     @example
     *     // Create many Properties
     *     const property = await prisma.property.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PropertyCreateManyArgs>(
      args?: SelectSubset<T, PropertyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
    **/
    delete<T extends PropertyDeleteArgs>(
      args: SelectSubset<T, PropertyDeleteArgs>
    ): CheckSelect<T, Prisma__PropertyClient<Property>, Prisma__PropertyClient<PropertyGetPayload<T>>>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyUpdateArgs>(
      args: SelectSubset<T, PropertyUpdateArgs>
    ): CheckSelect<T, Prisma__PropertyClient<Property>, Prisma__PropertyClient<PropertyGetPayload<T>>>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyDeleteManyArgs>(
      args?: SelectSubset<T, PropertyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyUpdateManyArgs>(
      args: SelectSubset<T, PropertyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyUpsertArgs>(
      args: SelectSubset<T, PropertyUpsertArgs>
    ): CheckSelect<T, Prisma__PropertyClient<Property>, Prisma__PropertyClient<PropertyGetPayload<T>>>

    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PropertyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    values<T extends PossibleValuesFindManyArgs = {}>(args?: Subset<T, PossibleValuesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PossibleValues>>, PrismaPromise<Array<PossibleValuesGetPayload<T>>>>;

    screenControl<T extends ScreenControlArgs = {}>(args?: Subset<T, ScreenControlArgs>): CheckSelect<T, Prisma__ScreenControlClient<ScreenControl | null >, Prisma__ScreenControlClient<ScreenControlGetPayload<T> | null >>;

    Category<T extends CategoryArgs = {}>(args?: Subset<T, CategoryArgs>): CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Property
    **/
    select?: PropertySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyInclude | null
    /**
     * Throw an Error if a Property can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Property to fetch.
    **/
    where: PropertyWhereUniqueInput
  }


  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Property
    **/
    select?: PropertySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyInclude | null
    /**
     * Throw an Error if a Property can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Property to fetch.
    **/
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
    **/
    orderBy?: Enumerable<PropertyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
    **/
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
    **/
    distinct?: Enumerable<PropertyScalarFieldEnum>
  }


  /**
   * Property findMany
   */
  export type PropertyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Property
    **/
    select?: PropertySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyInclude | null
    /**
     * Filter, which Properties to fetch.
    **/
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
    **/
    orderBy?: Enumerable<PropertyOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
    **/
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
    **/
    skip?: number
    distinct?: Enumerable<PropertyScalarFieldEnum>
  }


  /**
   * Property create
   */
  export type PropertyCreateArgs = {
    /**
     * Select specific fields to fetch from the Property
    **/
    select?: PropertySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyInclude | null
    /**
     * The data needed to create a Property.
    **/
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }


  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs = {
    data: Enumerable<PropertyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Property update
   */
  export type PropertyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Property
    **/
    select?: PropertySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyInclude | null
    /**
     * The data needed to update a Property.
    **/
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
    **/
    where: PropertyWhereUniqueInput
  }


  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs = {
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    where?: PropertyWhereInput
  }


  /**
   * Property upsert
   */
  export type PropertyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Property
    **/
    select?: PropertySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyInclude | null
    /**
     * The filter to search for the Property to update in case it exists.
    **/
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
    **/
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }


  /**
   * Property delete
   */
  export type PropertyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Property
    **/
    select?: PropertySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyInclude | null
    /**
     * Filter which Property to delete.
    **/
    where: PropertyWhereUniqueInput
  }


  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs = {
    where?: PropertyWhereInput
  }


  /**
   * Property without action
   */
  export type PropertyArgs = {
    /**
     * Select specific fields to fetch from the Property
    **/
    select?: PropertySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PropertyInclude | null
  }



  /**
   * Model PossibleValues
   */


  export type AggregatePossibleValues = {
    count: PossibleValuesCountAggregateOutputType | null
    avg: PossibleValuesAvgAggregateOutputType | null
    sum: PossibleValuesSumAggregateOutputType | null
    min: PossibleValuesMinAggregateOutputType | null
    max: PossibleValuesMaxAggregateOutputType | null
  }

  export type PossibleValuesAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    value: number | null
  }

  export type PossibleValuesSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    value: number | null
  }

  export type PossibleValuesMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    value: number | null
  }

  export type PossibleValuesMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    value: number | null
  }

  export type PossibleValuesCountAggregateOutputType = {
    id: number
    propertyId: number
    value: number
    _all: number
  }


  export type PossibleValuesAvgAggregateInputType = {
    id?: true
    propertyId?: true
    value?: true
  }

  export type PossibleValuesSumAggregateInputType = {
    id?: true
    propertyId?: true
    value?: true
  }

  export type PossibleValuesMinAggregateInputType = {
    id?: true
    propertyId?: true
    value?: true
  }

  export type PossibleValuesMaxAggregateInputType = {
    id?: true
    propertyId?: true
    value?: true
  }

  export type PossibleValuesCountAggregateInputType = {
    id?: true
    propertyId?: true
    value?: true
    _all?: true
  }

  export type PossibleValuesAggregateArgs = {
    /**
     * Filter which PossibleValues to aggregate.
    **/
    where?: PossibleValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PossibleValues to fetch.
    **/
    orderBy?: Enumerable<PossibleValuesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PossibleValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PossibleValues from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PossibleValues.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PossibleValues
    **/
    count?: true | PossibleValuesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PossibleValuesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PossibleValuesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PossibleValuesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PossibleValuesMaxAggregateInputType
  }

  export type GetPossibleValuesAggregateType<T extends PossibleValuesAggregateArgs> = {
    [P in keyof T & keyof AggregatePossibleValues]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePossibleValues[P]>
      : GetScalarType<T[P], AggregatePossibleValues[P]>
  }


    
    
  export type PossibleValuesGroupByArgs = {
    where?: PossibleValuesWhereInput
    orderBy?: Enumerable<PossibleValuesOrderByInput>
    by: Array<PossibleValuesScalarFieldEnum>
    having?: PossibleValuesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: PossibleValuesCountAggregateInputType | true
    avg?: PossibleValuesAvgAggregateInputType
    sum?: PossibleValuesSumAggregateInputType
    min?: PossibleValuesMinAggregateInputType
    max?: PossibleValuesMaxAggregateInputType
  }


  export type PossibleValuesGroupByOutputType = {
    id: number
    propertyId: number
    value: number
    count: PossibleValuesCountAggregateOutputType | null
    avg: PossibleValuesAvgAggregateOutputType | null
    sum: PossibleValuesSumAggregateOutputType | null
    min: PossibleValuesMinAggregateOutputType | null
    max: PossibleValuesMaxAggregateOutputType | null
  }

  type GetPossibleValuesGroupByPayload<T extends PossibleValuesGroupByArgs> = Promise<Array<
    PickArray<PossibleValuesGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof PossibleValuesGroupByOutputType))]: GetScalarType<T[P], PossibleValuesGroupByOutputType[P]>
    }
  >>
    

  export type PossibleValuesSelect = {
    id?: boolean
    propertyId?: boolean
    value?: boolean
    property?: boolean | PropertyArgs
  }

  export type PossibleValuesInclude = {
    property?: boolean | PropertyArgs
  }

  export type PossibleValuesGetPayload<
    S extends boolean | null | undefined | PossibleValuesArgs,
    U = keyof S
      > = S extends true
        ? PossibleValues
    : S extends undefined
    ? never
    : S extends PossibleValuesArgs | PossibleValuesFindManyArgs
    ?'include' extends U
    ? PossibleValues  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'property'
        ? PropertyGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PossibleValues ?PossibleValues [P]
  : 
          P extends 'property'
        ? PropertyGetPayload<S['select'][P]> : never
  } 
    : PossibleValues
  : PossibleValues


  type PossibleValuesCountArgs = Merge<
    Omit<PossibleValuesFindManyArgs, 'select' | 'include'> & {
      select?: PossibleValuesCountAggregateInputType | true
    }
  >

  export interface PossibleValuesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PossibleValues that matches the filter.
     * @param {PossibleValuesFindUniqueArgs} args - Arguments to find a PossibleValues
     * @example
     * // Get one PossibleValues
     * const possibleValues = await prisma.possibleValues.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PossibleValuesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PossibleValuesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PossibleValues'> extends True ? CheckSelect<T, Prisma__PossibleValuesClient<PossibleValues>, Prisma__PossibleValuesClient<PossibleValuesGetPayload<T>>> : CheckSelect<T, Prisma__PossibleValuesClient<PossibleValues | null >, Prisma__PossibleValuesClient<PossibleValuesGetPayload<T> | null >>

    /**
     * Find the first PossibleValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PossibleValuesFindFirstArgs} args - Arguments to find a PossibleValues
     * @example
     * // Get one PossibleValues
     * const possibleValues = await prisma.possibleValues.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PossibleValuesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PossibleValuesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PossibleValues'> extends True ? CheckSelect<T, Prisma__PossibleValuesClient<PossibleValues>, Prisma__PossibleValuesClient<PossibleValuesGetPayload<T>>> : CheckSelect<T, Prisma__PossibleValuesClient<PossibleValues | null >, Prisma__PossibleValuesClient<PossibleValuesGetPayload<T> | null >>

    /**
     * Find zero or more PossibleValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PossibleValuesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PossibleValues
     * const possibleValues = await prisma.possibleValues.findMany()
     * 
     * // Get first 10 PossibleValues
     * const possibleValues = await prisma.possibleValues.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const possibleValuesWithIdOnly = await prisma.possibleValues.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PossibleValuesFindManyArgs>(
      args?: SelectSubset<T, PossibleValuesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PossibleValues>>, PrismaPromise<Array<PossibleValuesGetPayload<T>>>>

    /**
     * Create a PossibleValues.
     * @param {PossibleValuesCreateArgs} args - Arguments to create a PossibleValues.
     * @example
     * // Create one PossibleValues
     * const PossibleValues = await prisma.possibleValues.create({
     *   data: {
     *     // ... data to create a PossibleValues
     *   }
     * })
     * 
    **/
    create<T extends PossibleValuesCreateArgs>(
      args: SelectSubset<T, PossibleValuesCreateArgs>
    ): CheckSelect<T, Prisma__PossibleValuesClient<PossibleValues>, Prisma__PossibleValuesClient<PossibleValuesGetPayload<T>>>

    /**
     * Create many PossibleValues.
     *     @param {PossibleValuesCreateManyArgs} args - Arguments to create many PossibleValues.
     *     @example
     *     // Create many PossibleValues
     *     const possibleValues = await prisma.possibleValues.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PossibleValuesCreateManyArgs>(
      args?: SelectSubset<T, PossibleValuesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PossibleValues.
     * @param {PossibleValuesDeleteArgs} args - Arguments to delete one PossibleValues.
     * @example
     * // Delete one PossibleValues
     * const PossibleValues = await prisma.possibleValues.delete({
     *   where: {
     *     // ... filter to delete one PossibleValues
     *   }
     * })
     * 
    **/
    delete<T extends PossibleValuesDeleteArgs>(
      args: SelectSubset<T, PossibleValuesDeleteArgs>
    ): CheckSelect<T, Prisma__PossibleValuesClient<PossibleValues>, Prisma__PossibleValuesClient<PossibleValuesGetPayload<T>>>

    /**
     * Update one PossibleValues.
     * @param {PossibleValuesUpdateArgs} args - Arguments to update one PossibleValues.
     * @example
     * // Update one PossibleValues
     * const possibleValues = await prisma.possibleValues.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PossibleValuesUpdateArgs>(
      args: SelectSubset<T, PossibleValuesUpdateArgs>
    ): CheckSelect<T, Prisma__PossibleValuesClient<PossibleValues>, Prisma__PossibleValuesClient<PossibleValuesGetPayload<T>>>

    /**
     * Delete zero or more PossibleValues.
     * @param {PossibleValuesDeleteManyArgs} args - Arguments to filter PossibleValues to delete.
     * @example
     * // Delete a few PossibleValues
     * const { count } = await prisma.possibleValues.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PossibleValuesDeleteManyArgs>(
      args?: SelectSubset<T, PossibleValuesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PossibleValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PossibleValuesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PossibleValues
     * const possibleValues = await prisma.possibleValues.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PossibleValuesUpdateManyArgs>(
      args: SelectSubset<T, PossibleValuesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PossibleValues.
     * @param {PossibleValuesUpsertArgs} args - Arguments to update or create a PossibleValues.
     * @example
     * // Update or create a PossibleValues
     * const possibleValues = await prisma.possibleValues.upsert({
     *   create: {
     *     // ... data to create a PossibleValues
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PossibleValues we want to update
     *   }
     * })
    **/
    upsert<T extends PossibleValuesUpsertArgs>(
      args: SelectSubset<T, PossibleValuesUpsertArgs>
    ): CheckSelect<T, Prisma__PossibleValuesClient<PossibleValues>, Prisma__PossibleValuesClient<PossibleValuesGetPayload<T>>>

    /**
     * Count the number of PossibleValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PossibleValuesCountArgs} args - Arguments to filter PossibleValues to count.
     * @example
     * // Count the number of PossibleValues
     * const count = await prisma.possibleValues.count({
     *   where: {
     *     // ... the filter for the PossibleValues we want to count
     *   }
     * })
    **/
    count<T extends PossibleValuesCountArgs>(
      args?: Subset<T, PossibleValuesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PossibleValuesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PossibleValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PossibleValuesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PossibleValuesAggregateArgs>(args: Subset<T, PossibleValuesAggregateArgs>): PrismaPromise<GetPossibleValuesAggregateType<T>>

    /**
     * Group by PossibleValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PossibleValuesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PossibleValuesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PossibleValuesGroupByArgs['orderBy'] }
        : { orderBy?: PossibleValuesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PossibleValuesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPossibleValuesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PossibleValues.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PossibleValuesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    property<T extends PropertyArgs = {}>(args?: Subset<T, PropertyArgs>): CheckSelect<T, Prisma__PropertyClient<Property | null >, Prisma__PropertyClient<PropertyGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PossibleValues findUnique
   */
  export type PossibleValuesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PossibleValues
    **/
    select?: PossibleValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PossibleValuesInclude | null
    /**
     * Throw an Error if a PossibleValues can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PossibleValues to fetch.
    **/
    where: PossibleValuesWhereUniqueInput
  }


  /**
   * PossibleValues findFirst
   */
  export type PossibleValuesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PossibleValues
    **/
    select?: PossibleValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PossibleValuesInclude | null
    /**
     * Throw an Error if a PossibleValues can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PossibleValues to fetch.
    **/
    where?: PossibleValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PossibleValues to fetch.
    **/
    orderBy?: Enumerable<PossibleValuesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PossibleValues.
    **/
    cursor?: PossibleValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PossibleValues from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PossibleValues.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PossibleValues.
    **/
    distinct?: Enumerable<PossibleValuesScalarFieldEnum>
  }


  /**
   * PossibleValues findMany
   */
  export type PossibleValuesFindManyArgs = {
    /**
     * Select specific fields to fetch from the PossibleValues
    **/
    select?: PossibleValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PossibleValuesInclude | null
    /**
     * Filter, which PossibleValues to fetch.
    **/
    where?: PossibleValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PossibleValues to fetch.
    **/
    orderBy?: Enumerable<PossibleValuesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PossibleValues.
    **/
    cursor?: PossibleValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PossibleValues from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PossibleValues.
    **/
    skip?: number
    distinct?: Enumerable<PossibleValuesScalarFieldEnum>
  }


  /**
   * PossibleValues create
   */
  export type PossibleValuesCreateArgs = {
    /**
     * Select specific fields to fetch from the PossibleValues
    **/
    select?: PossibleValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PossibleValuesInclude | null
    /**
     * The data needed to create a PossibleValues.
    **/
    data: XOR<PossibleValuesCreateInput, PossibleValuesUncheckedCreateInput>
  }


  /**
   * PossibleValues createMany
   */
  export type PossibleValuesCreateManyArgs = {
    data: Enumerable<PossibleValuesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PossibleValues update
   */
  export type PossibleValuesUpdateArgs = {
    /**
     * Select specific fields to fetch from the PossibleValues
    **/
    select?: PossibleValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PossibleValuesInclude | null
    /**
     * The data needed to update a PossibleValues.
    **/
    data: XOR<PossibleValuesUpdateInput, PossibleValuesUncheckedUpdateInput>
    /**
     * Choose, which PossibleValues to update.
    **/
    where: PossibleValuesWhereUniqueInput
  }


  /**
   * PossibleValues updateMany
   */
  export type PossibleValuesUpdateManyArgs = {
    data: XOR<PossibleValuesUpdateManyMutationInput, PossibleValuesUncheckedUpdateManyInput>
    where?: PossibleValuesWhereInput
  }


  /**
   * PossibleValues upsert
   */
  export type PossibleValuesUpsertArgs = {
    /**
     * Select specific fields to fetch from the PossibleValues
    **/
    select?: PossibleValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PossibleValuesInclude | null
    /**
     * The filter to search for the PossibleValues to update in case it exists.
    **/
    where: PossibleValuesWhereUniqueInput
    /**
     * In case the PossibleValues found by the `where` argument doesn't exist, create a new PossibleValues with this data.
    **/
    create: XOR<PossibleValuesCreateInput, PossibleValuesUncheckedCreateInput>
    /**
     * In case the PossibleValues was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PossibleValuesUpdateInput, PossibleValuesUncheckedUpdateInput>
  }


  /**
   * PossibleValues delete
   */
  export type PossibleValuesDeleteArgs = {
    /**
     * Select specific fields to fetch from the PossibleValues
    **/
    select?: PossibleValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PossibleValuesInclude | null
    /**
     * Filter which PossibleValues to delete.
    **/
    where: PossibleValuesWhereUniqueInput
  }


  /**
   * PossibleValues deleteMany
   */
  export type PossibleValuesDeleteManyArgs = {
    where?: PossibleValuesWhereInput
  }


  /**
   * PossibleValues without action
   */
  export type PossibleValuesArgs = {
    /**
     * Select specific fields to fetch from the PossibleValues
    **/
    select?: PossibleValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PossibleValuesInclude | null
  }



  /**
   * Model ScreenControl
   */


  export type AggregateScreenControl = {
    count: ScreenControlCountAggregateOutputType | null
    avg: ScreenControlAvgAggregateOutputType | null
    sum: ScreenControlSumAggregateOutputType | null
    min: ScreenControlMinAggregateOutputType | null
    max: ScreenControlMaxAggregateOutputType | null
  }

  export type ScreenControlAvgAggregateOutputType = {
    id: number | null
  }

  export type ScreenControlSumAggregateOutputType = {
    id: number | null
  }

  export type ScreenControlMinAggregateOutputType = {
    id: number | null
    screenControl: string | null
  }

  export type ScreenControlMaxAggregateOutputType = {
    id: number | null
    screenControl: string | null
  }

  export type ScreenControlCountAggregateOutputType = {
    id: number
    screenControl: number
    _all: number
  }


  export type ScreenControlAvgAggregateInputType = {
    id?: true
  }

  export type ScreenControlSumAggregateInputType = {
    id?: true
  }

  export type ScreenControlMinAggregateInputType = {
    id?: true
    screenControl?: true
  }

  export type ScreenControlMaxAggregateInputType = {
    id?: true
    screenControl?: true
  }

  export type ScreenControlCountAggregateInputType = {
    id?: true
    screenControl?: true
    _all?: true
  }

  export type ScreenControlAggregateArgs = {
    /**
     * Filter which ScreenControl to aggregate.
    **/
    where?: ScreenControlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenControls to fetch.
    **/
    orderBy?: Enumerable<ScreenControlOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ScreenControlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenControls from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenControls.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScreenControls
    **/
    count?: true | ScreenControlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ScreenControlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ScreenControlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ScreenControlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ScreenControlMaxAggregateInputType
  }

  export type GetScreenControlAggregateType<T extends ScreenControlAggregateArgs> = {
    [P in keyof T & keyof AggregateScreenControl]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenControl[P]>
      : GetScalarType<T[P], AggregateScreenControl[P]>
  }


    
    
  export type ScreenControlGroupByArgs = {
    where?: ScreenControlWhereInput
    orderBy?: Enumerable<ScreenControlOrderByInput>
    by: Array<ScreenControlScalarFieldEnum>
    having?: ScreenControlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ScreenControlCountAggregateInputType | true
    avg?: ScreenControlAvgAggregateInputType
    sum?: ScreenControlSumAggregateInputType
    min?: ScreenControlMinAggregateInputType
    max?: ScreenControlMaxAggregateInputType
  }


  export type ScreenControlGroupByOutputType = {
    id: number
    screenControl: string
    count: ScreenControlCountAggregateOutputType | null
    avg: ScreenControlAvgAggregateOutputType | null
    sum: ScreenControlSumAggregateOutputType | null
    min: ScreenControlMinAggregateOutputType | null
    max: ScreenControlMaxAggregateOutputType | null
  }

  type GetScreenControlGroupByPayload<T extends ScreenControlGroupByArgs> = Promise<Array<
    PickArray<ScreenControlGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ScreenControlGroupByOutputType))]: GetScalarType<T[P], ScreenControlGroupByOutputType[P]>
    }
  >>
    

  export type ScreenControlSelect = {
    id?: boolean
    screenControl?: boolean
    Property?: boolean | PropertyFindManyArgs
  }

  export type ScreenControlInclude = {
    Property?: boolean | PropertyFindManyArgs
  }

  export type ScreenControlGetPayload<
    S extends boolean | null | undefined | ScreenControlArgs,
    U = keyof S
      > = S extends true
        ? ScreenControl
    : S extends undefined
    ? never
    : S extends ScreenControlArgs | ScreenControlFindManyArgs
    ?'include' extends U
    ? ScreenControl  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Property'
        ? Array < PropertyGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ScreenControl ?ScreenControl [P]
  : 
          P extends 'Property'
        ? Array < PropertyGetPayload<S['select'][P]>>  : never
  } 
    : ScreenControl
  : ScreenControl


  type ScreenControlCountArgs = Merge<
    Omit<ScreenControlFindManyArgs, 'select' | 'include'> & {
      select?: ScreenControlCountAggregateInputType | true
    }
  >

  export interface ScreenControlDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ScreenControl that matches the filter.
     * @param {ScreenControlFindUniqueArgs} args - Arguments to find a ScreenControl
     * @example
     * // Get one ScreenControl
     * const screenControl = await prisma.screenControl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScreenControlFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ScreenControlFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ScreenControl'> extends True ? CheckSelect<T, Prisma__ScreenControlClient<ScreenControl>, Prisma__ScreenControlClient<ScreenControlGetPayload<T>>> : CheckSelect<T, Prisma__ScreenControlClient<ScreenControl | null >, Prisma__ScreenControlClient<ScreenControlGetPayload<T> | null >>

    /**
     * Find the first ScreenControl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenControlFindFirstArgs} args - Arguments to find a ScreenControl
     * @example
     * // Get one ScreenControl
     * const screenControl = await prisma.screenControl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScreenControlFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ScreenControlFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ScreenControl'> extends True ? CheckSelect<T, Prisma__ScreenControlClient<ScreenControl>, Prisma__ScreenControlClient<ScreenControlGetPayload<T>>> : CheckSelect<T, Prisma__ScreenControlClient<ScreenControl | null >, Prisma__ScreenControlClient<ScreenControlGetPayload<T> | null >>

    /**
     * Find zero or more ScreenControls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenControlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScreenControls
     * const screenControls = await prisma.screenControl.findMany()
     * 
     * // Get first 10 ScreenControls
     * const screenControls = await prisma.screenControl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const screenControlWithIdOnly = await prisma.screenControl.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ScreenControlFindManyArgs>(
      args?: SelectSubset<T, ScreenControlFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ScreenControl>>, PrismaPromise<Array<ScreenControlGetPayload<T>>>>

    /**
     * Create a ScreenControl.
     * @param {ScreenControlCreateArgs} args - Arguments to create a ScreenControl.
     * @example
     * // Create one ScreenControl
     * const ScreenControl = await prisma.screenControl.create({
     *   data: {
     *     // ... data to create a ScreenControl
     *   }
     * })
     * 
    **/
    create<T extends ScreenControlCreateArgs>(
      args: SelectSubset<T, ScreenControlCreateArgs>
    ): CheckSelect<T, Prisma__ScreenControlClient<ScreenControl>, Prisma__ScreenControlClient<ScreenControlGetPayload<T>>>

    /**
     * Create many ScreenControls.
     *     @param {ScreenControlCreateManyArgs} args - Arguments to create many ScreenControls.
     *     @example
     *     // Create many ScreenControls
     *     const screenControl = await prisma.screenControl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ScreenControlCreateManyArgs>(
      args?: SelectSubset<T, ScreenControlCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ScreenControl.
     * @param {ScreenControlDeleteArgs} args - Arguments to delete one ScreenControl.
     * @example
     * // Delete one ScreenControl
     * const ScreenControl = await prisma.screenControl.delete({
     *   where: {
     *     // ... filter to delete one ScreenControl
     *   }
     * })
     * 
    **/
    delete<T extends ScreenControlDeleteArgs>(
      args: SelectSubset<T, ScreenControlDeleteArgs>
    ): CheckSelect<T, Prisma__ScreenControlClient<ScreenControl>, Prisma__ScreenControlClient<ScreenControlGetPayload<T>>>

    /**
     * Update one ScreenControl.
     * @param {ScreenControlUpdateArgs} args - Arguments to update one ScreenControl.
     * @example
     * // Update one ScreenControl
     * const screenControl = await prisma.screenControl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScreenControlUpdateArgs>(
      args: SelectSubset<T, ScreenControlUpdateArgs>
    ): CheckSelect<T, Prisma__ScreenControlClient<ScreenControl>, Prisma__ScreenControlClient<ScreenControlGetPayload<T>>>

    /**
     * Delete zero or more ScreenControls.
     * @param {ScreenControlDeleteManyArgs} args - Arguments to filter ScreenControls to delete.
     * @example
     * // Delete a few ScreenControls
     * const { count } = await prisma.screenControl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScreenControlDeleteManyArgs>(
      args?: SelectSubset<T, ScreenControlDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScreenControls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenControlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScreenControls
     * const screenControl = await prisma.screenControl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScreenControlUpdateManyArgs>(
      args: SelectSubset<T, ScreenControlUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ScreenControl.
     * @param {ScreenControlUpsertArgs} args - Arguments to update or create a ScreenControl.
     * @example
     * // Update or create a ScreenControl
     * const screenControl = await prisma.screenControl.upsert({
     *   create: {
     *     // ... data to create a ScreenControl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScreenControl we want to update
     *   }
     * })
    **/
    upsert<T extends ScreenControlUpsertArgs>(
      args: SelectSubset<T, ScreenControlUpsertArgs>
    ): CheckSelect<T, Prisma__ScreenControlClient<ScreenControl>, Prisma__ScreenControlClient<ScreenControlGetPayload<T>>>

    /**
     * Count the number of ScreenControls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenControlCountArgs} args - Arguments to filter ScreenControls to count.
     * @example
     * // Count the number of ScreenControls
     * const count = await prisma.screenControl.count({
     *   where: {
     *     // ... the filter for the ScreenControls we want to count
     *   }
     * })
    **/
    count<T extends ScreenControlCountArgs>(
      args?: Subset<T, ScreenControlCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenControlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScreenControl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenControlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenControlAggregateArgs>(args: Subset<T, ScreenControlAggregateArgs>): PrismaPromise<GetScreenControlAggregateType<T>>

    /**
     * Group by ScreenControl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenControlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScreenControlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenControlGroupByArgs['orderBy'] }
        : { orderBy?: ScreenControlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScreenControlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenControlGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScreenControl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ScreenControlClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Property<T extends PropertyFindManyArgs = {}>(args?: Subset<T, PropertyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Property>>, PrismaPromise<Array<PropertyGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ScreenControl findUnique
   */
  export type ScreenControlFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ScreenControl
    **/
    select?: ScreenControlSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScreenControlInclude | null
    /**
     * Throw an Error if a ScreenControl can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ScreenControl to fetch.
    **/
    where: ScreenControlWhereUniqueInput
  }


  /**
   * ScreenControl findFirst
   */
  export type ScreenControlFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ScreenControl
    **/
    select?: ScreenControlSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScreenControlInclude | null
    /**
     * Throw an Error if a ScreenControl can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ScreenControl to fetch.
    **/
    where?: ScreenControlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenControls to fetch.
    **/
    orderBy?: Enumerable<ScreenControlOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScreenControls.
    **/
    cursor?: ScreenControlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenControls from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenControls.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScreenControls.
    **/
    distinct?: Enumerable<ScreenControlScalarFieldEnum>
  }


  /**
   * ScreenControl findMany
   */
  export type ScreenControlFindManyArgs = {
    /**
     * Select specific fields to fetch from the ScreenControl
    **/
    select?: ScreenControlSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScreenControlInclude | null
    /**
     * Filter, which ScreenControls to fetch.
    **/
    where?: ScreenControlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScreenControls to fetch.
    **/
    orderBy?: Enumerable<ScreenControlOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScreenControls.
    **/
    cursor?: ScreenControlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScreenControls from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScreenControls.
    **/
    skip?: number
    distinct?: Enumerable<ScreenControlScalarFieldEnum>
  }


  /**
   * ScreenControl create
   */
  export type ScreenControlCreateArgs = {
    /**
     * Select specific fields to fetch from the ScreenControl
    **/
    select?: ScreenControlSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScreenControlInclude | null
    /**
     * The data needed to create a ScreenControl.
    **/
    data: XOR<ScreenControlCreateInput, ScreenControlUncheckedCreateInput>
  }


  /**
   * ScreenControl createMany
   */
  export type ScreenControlCreateManyArgs = {
    data: Enumerable<ScreenControlCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ScreenControl update
   */
  export type ScreenControlUpdateArgs = {
    /**
     * Select specific fields to fetch from the ScreenControl
    **/
    select?: ScreenControlSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScreenControlInclude | null
    /**
     * The data needed to update a ScreenControl.
    **/
    data: XOR<ScreenControlUpdateInput, ScreenControlUncheckedUpdateInput>
    /**
     * Choose, which ScreenControl to update.
    **/
    where: ScreenControlWhereUniqueInput
  }


  /**
   * ScreenControl updateMany
   */
  export type ScreenControlUpdateManyArgs = {
    data: XOR<ScreenControlUpdateManyMutationInput, ScreenControlUncheckedUpdateManyInput>
    where?: ScreenControlWhereInput
  }


  /**
   * ScreenControl upsert
   */
  export type ScreenControlUpsertArgs = {
    /**
     * Select specific fields to fetch from the ScreenControl
    **/
    select?: ScreenControlSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScreenControlInclude | null
    /**
     * The filter to search for the ScreenControl to update in case it exists.
    **/
    where: ScreenControlWhereUniqueInput
    /**
     * In case the ScreenControl found by the `where` argument doesn't exist, create a new ScreenControl with this data.
    **/
    create: XOR<ScreenControlCreateInput, ScreenControlUncheckedCreateInput>
    /**
     * In case the ScreenControl was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ScreenControlUpdateInput, ScreenControlUncheckedUpdateInput>
  }


  /**
   * ScreenControl delete
   */
  export type ScreenControlDeleteArgs = {
    /**
     * Select specific fields to fetch from the ScreenControl
    **/
    select?: ScreenControlSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScreenControlInclude | null
    /**
     * Filter which ScreenControl to delete.
    **/
    where: ScreenControlWhereUniqueInput
  }


  /**
   * ScreenControl deleteMany
   */
  export type ScreenControlDeleteManyArgs = {
    where?: ScreenControlWhereInput
  }


  /**
   * ScreenControl without action
   */
  export type ScreenControlArgs = {
    /**
     * Select specific fields to fetch from the ScreenControl
    **/
    select?: ScreenControlSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ScreenControlInclude | null
  }



  /**
   * Model Post
   */


  export type AggregatePost = {
    count: PostCountAggregateOutputType | null
    avg: PostAvgAggregateOutputType | null
    sum: PostSumAggregateOutputType | null
    min: PostMinAggregateOutputType | null
    max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    expectedPrice: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    expectedPrice: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    createdAt: Date | null
    lastRenewedAt: Date | null
    title: string | null
    detail: string | null
    isActive: boolean | null
    isSeller: boolean | null
    isIndividual: boolean | null
    expectedPrice: number | null
    isPriceNegotiable: boolean | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    createdAt: Date | null
    lastRenewedAt: Date | null
    title: string | null
    detail: string | null
    isActive: boolean | null
    isSeller: boolean | null
    isIndividual: boolean | null
    expectedPrice: number | null
    isPriceNegotiable: boolean | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    userId: number
    categoryId: number
    createdAt: number
    lastRenewedAt: number
    title: number
    detail: number
    isActive: number
    isSeller: number
    isIndividual: number
    expectedPrice: number
    isPriceNegotiable: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    expectedPrice?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    expectedPrice?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    createdAt?: true
    lastRenewedAt?: true
    title?: true
    detail?: true
    isActive?: true
    isSeller?: true
    isIndividual?: true
    expectedPrice?: true
    isPriceNegotiable?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    createdAt?: true
    lastRenewedAt?: true
    title?: true
    detail?: true
    isActive?: true
    isSeller?: true
    isIndividual?: true
    expectedPrice?: true
    isPriceNegotiable?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    createdAt?: true
    lastRenewedAt?: true
    title?: true
    detail?: true
    isActive?: true
    isSeller?: true
    isIndividual?: true
    expectedPrice?: true
    isPriceNegotiable?: true
    _all?: true
  }

  export type PostAggregateArgs = {
    /**
     * Filter which Post to aggregate.
    **/
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
    **/
    orderBy?: Enumerable<PostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
    [P in keyof T & keyof AggregatePost]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }


    
    
  export type PostGroupByArgs = {
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByInput>
    by: Array<PostScalarFieldEnum>
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: PostCountAggregateInputType | true
    avg?: PostAvgAggregateInputType
    sum?: PostSumAggregateInputType
    min?: PostMinAggregateInputType
    max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    id: number
    userId: number
    categoryId: number
    createdAt: Date
    lastRenewedAt: Date
    title: string
    detail: string
    isActive: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice: number | null
    isPriceNegotiable: boolean
    count: PostCountAggregateOutputType | null
    avg: PostAvgAggregateOutputType | null
    sum: PostSumAggregateOutputType | null
    min: PostMinAggregateOutputType | null
    max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Promise<Array<
    PickArray<PostGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof PostGroupByOutputType))]: GetScalarType<T[P], PostGroupByOutputType[P]>
    }
  >>
    

  export type PostSelect = {
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    lastRenewedAt?: boolean
    title?: boolean
    detail?: boolean
    isActive?: boolean
    isSeller?: boolean
    isIndividual?: boolean
    expectedPrice?: boolean
    isPriceNegotiable?: boolean
    category?: boolean | CategoryArgs
    user?: boolean | UserArgs
    images?: boolean | ImageFindManyArgs
  }

  export type PostInclude = {
    category?: boolean | CategoryArgs
    user?: boolean | UserArgs
    images?: boolean | ImageFindManyArgs
  }

  export type PostGetPayload<
    S extends boolean | null | undefined | PostArgs,
    U = keyof S
      > = S extends true
        ? Post
    : S extends undefined
    ? never
    : S extends PostArgs | PostFindManyArgs
    ?'include' extends U
    ? Post  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'category'
        ? CategoryGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'images'
        ? Array < ImageGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Post ?Post [P]
  : 
          P extends 'category'
        ? CategoryGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'images'
        ? Array < ImageGetPayload<S['select'][P]>>  : never
  } 
    : Post
  : Post


  type PostCountArgs = Merge<
    Omit<PostFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }
  >

  export interface PostDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Post'> extends True ? CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>> : CheckSelect<T, Prisma__PostClient<Post | null >, Prisma__PostClient<PostGetPayload<T> | null >>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Post'> extends True ? CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>> : CheckSelect<T, Prisma__PostClient<Post | null >, Prisma__PostClient<PostGetPayload<T> | null >>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs>(
      args?: SelectSubset<T, PostFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Post>>, PrismaPromise<Array<PostGetPayload<T>>>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs>(
      args: SelectSubset<T, PostCreateArgs>
    ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs>(
      args?: SelectSubset<T, PostCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs>(
      args: SelectSubset<T, PostDeleteArgs>
    ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs>(
      args: SelectSubset<T, PostUpdateArgs>
    ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs>(
      args?: SelectSubset<T, PostDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs>(
      args: SelectSubset<T, PostUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs>(
      args: SelectSubset<T, PostUpsertArgs>
    ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    category<T extends CategoryArgs = {}>(args?: Subset<T, CategoryArgs>): CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    images<T extends ImageFindManyArgs = {}>(args?: Subset<T, ImageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Image>>, PrismaPromise<Array<ImageGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Post
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PostInclude | null
    /**
     * Throw an Error if a Post can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Post to fetch.
    **/
    where: PostWhereUniqueInput
  }


  /**
   * Post findFirst
   */
  export type PostFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Post
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PostInclude | null
    /**
     * Throw an Error if a Post can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Post to fetch.
    **/
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
    **/
    orderBy?: Enumerable<PostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
    **/
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
    **/
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Post
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PostInclude | null
    /**
     * Filter, which Posts to fetch.
    **/
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
    **/
    orderBy?: Enumerable<PostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
    **/
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
    **/
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post create
   */
  export type PostCreateArgs = {
    /**
     * Select specific fields to fetch from the Post
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PostInclude | null
    /**
     * The data needed to create a Post.
    **/
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs = {
    data: Enumerable<PostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Post
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PostInclude | null
    /**
     * The data needed to update a Post.
    **/
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
    **/
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs = {
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Post
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PostInclude | null
    /**
     * The filter to search for the Post to update in case it exists.
    **/
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
    **/
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Post
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PostInclude | null
    /**
     * Filter which Post to delete.
    **/
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs = {
    where?: PostWhereInput
  }


  /**
   * Post without action
   */
  export type PostArgs = {
    /**
     * Select specific fields to fetch from the Post
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PostInclude | null
  }



  /**
   * Model Image
   */


  export type AggregateImage = {
    count: ImageCountAggregateOutputType | null
    avg: ImageAvgAggregateOutputType | null
    sum: ImageSumAggregateOutputType | null
    min: ImageMinAggregateOutputType | null
    max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: number | null
    postId: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: number | null
    postId: number | null
    name: string | null
    url: string | null
  }

  export type ImageMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    name: string | null
    url: string | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    postId: number
    name: number
    url: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
    postId?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
    postId?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    postId?: true
    name?: true
    url?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    postId?: true
    name?: true
    url?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    postId?: true
    name?: true
    url?: true
    _all?: true
  }

  export type ImageAggregateArgs = {
    /**
     * Filter which Image to aggregate.
    **/
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
    **/
    orderBy?: Enumerable<ImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
    [P in keyof T & keyof AggregateImage]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }


    
    
  export type ImageGroupByArgs = {
    where?: ImageWhereInput
    orderBy?: Enumerable<ImageOrderByInput>
    by: Array<ImageScalarFieldEnum>
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ImageCountAggregateInputType | true
    avg?: ImageAvgAggregateInputType
    sum?: ImageSumAggregateInputType
    min?: ImageMinAggregateInputType
    max?: ImageMaxAggregateInputType
  }


  export type ImageGroupByOutputType = {
    id: number
    postId: number
    name: string
    url: string
    count: ImageCountAggregateOutputType | null
    avg: ImageAvgAggregateOutputType | null
    sum: ImageSumAggregateOutputType | null
    min: ImageMinAggregateOutputType | null
    max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Promise<Array<
    PickArray<ImageGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ImageGroupByOutputType))]: GetScalarType<T[P], ImageGroupByOutputType[P]>
    }
  >>
    

  export type ImageSelect = {
    id?: boolean
    postId?: boolean
    name?: boolean
    url?: boolean
    post?: boolean | PostArgs
  }

  export type ImageInclude = {
    post?: boolean | PostArgs
  }

  export type ImageGetPayload<
    S extends boolean | null | undefined | ImageArgs,
    U = keyof S
      > = S extends true
        ? Image
    : S extends undefined
    ? never
    : S extends ImageArgs | ImageFindManyArgs
    ?'include' extends U
    ? Image  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'post'
        ? PostGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Image ?Image [P]
  : 
          P extends 'post'
        ? PostGetPayload<S['select'][P]> : never
  } 
    : Image
  : Image


  type ImageCountArgs = Merge<
    Omit<ImageFindManyArgs, 'select' | 'include'> & {
      select?: ImageCountAggregateInputType | true
    }
  >

  export interface ImageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Image'> extends True ? CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>> : CheckSelect<T, Prisma__ImageClient<Image | null >, Prisma__ImageClient<ImageGetPayload<T> | null >>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Image'> extends True ? CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>> : CheckSelect<T, Prisma__ImageClient<Image | null >, Prisma__ImageClient<ImageGetPayload<T> | null >>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageFindManyArgs>(
      args?: SelectSubset<T, ImageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Image>>, PrismaPromise<Array<ImageGetPayload<T>>>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
    **/
    create<T extends ImageCreateArgs>(
      args: SelectSubset<T, ImageCreateArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Create many Images.
     *     @param {ImageCreateManyArgs} args - Arguments to create many Images.
     *     @example
     *     // Create many Images
     *     const image = await prisma.image.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageCreateManyArgs>(
      args?: SelectSubset<T, ImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
    **/
    delete<T extends ImageDeleteArgs>(
      args: SelectSubset<T, ImageDeleteArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageUpdateArgs>(
      args: SelectSubset<T, ImageUpdateArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageDeleteManyArgs>(
      args?: SelectSubset<T, ImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageUpdateManyArgs>(
      args: SelectSubset<T, ImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
    **/
    upsert<T extends ImageUpsertArgs>(
      args: SelectSubset<T, ImageUpsertArgs>
    ): CheckSelect<T, Prisma__ImageClient<Image>, Prisma__ImageClient<ImageGetPayload<T>>>

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    post<T extends PostArgs = {}>(args?: Subset<T, PostArgs>): CheckSelect<T, Prisma__PostClient<Post | null >, Prisma__PostClient<PostGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * Throw an Error if a Image can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Image to fetch.
    **/
    where: ImageWhereUniqueInput
  }


  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * Throw an Error if a Image can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Image to fetch.
    **/
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
    **/
    orderBy?: Enumerable<ImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
    **/
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
    **/
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image findMany
   */
  export type ImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * Filter, which Images to fetch.
    **/
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
    **/
    orderBy?: Enumerable<ImageOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
    **/
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
    **/
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image create
   */
  export type ImageCreateArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * The data needed to create a Image.
    **/
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }


  /**
   * Image createMany
   */
  export type ImageCreateManyArgs = {
    data: Enumerable<ImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Image update
   */
  export type ImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * The data needed to update a Image.
    **/
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
    **/
    where: ImageWhereUniqueInput
  }


  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs = {
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    where?: ImageWhereInput
  }


  /**
   * Image upsert
   */
  export type ImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * The filter to search for the Image to update in case it exists.
    **/
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
    **/
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }


  /**
   * Image delete
   */
  export type ImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
    /**
     * Filter which Image to delete.
    **/
    where: ImageWhereUniqueInput
  }


  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs = {
    where?: ImageWhereInput
  }


  /**
   * Image without action
   */
  export type ImageArgs = {
    /**
     * Select specific fields to fetch from the Image
    **/
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ImageInclude | null
  }



  /**
   * Model Attribute
   */


  export type AggregateAttribute = {
    count: AttributeCountAggregateOutputType | null
    avg: AttributeAvgAggregateOutputType | null
    sum: AttributeSumAggregateOutputType | null
    min: AttributeMinAggregateOutputType | null
    max: AttributeMaxAggregateOutputType | null
  }

  export type AttributeAvgAggregateOutputType = {
    id: number | null
  }

  export type AttributeSumAggregateOutputType = {
    id: number | null
  }

  export type AttributeMinAggregateOutputType = {
    id: number | null
  }

  export type AttributeMaxAggregateOutputType = {
    id: number | null
  }

  export type AttributeCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type AttributeAvgAggregateInputType = {
    id?: true
  }

  export type AttributeSumAggregateInputType = {
    id?: true
  }

  export type AttributeMinAggregateInputType = {
    id?: true
  }

  export type AttributeMaxAggregateInputType = {
    id?: true
  }

  export type AttributeCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type AttributeAggregateArgs = {
    /**
     * Filter which Attribute to aggregate.
    **/
    where?: AttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attributes to fetch.
    **/
    orderBy?: Enumerable<AttributeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attributes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attributes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attributes
    **/
    count?: true | AttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AttributeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AttributeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AttributeMaxAggregateInputType
  }

  export type GetAttributeAggregateType<T extends AttributeAggregateArgs> = {
    [P in keyof T & keyof AggregateAttribute]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttribute[P]>
      : GetScalarType<T[P], AggregateAttribute[P]>
  }


    
    
  export type AttributeGroupByArgs = {
    where?: AttributeWhereInput
    orderBy?: Enumerable<AttributeOrderByInput>
    by: Array<AttributeScalarFieldEnum>
    having?: AttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: AttributeCountAggregateInputType | true
    avg?: AttributeAvgAggregateInputType
    sum?: AttributeSumAggregateInputType
    min?: AttributeMinAggregateInputType
    max?: AttributeMaxAggregateInputType
  }


  export type AttributeGroupByOutputType = {
    id: number
    count: AttributeCountAggregateOutputType | null
    avg: AttributeAvgAggregateOutputType | null
    sum: AttributeSumAggregateOutputType | null
    min: AttributeMinAggregateOutputType | null
    max: AttributeMaxAggregateOutputType | null
  }

  type GetAttributeGroupByPayload<T extends AttributeGroupByArgs> = Promise<Array<
    PickArray<AttributeGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof AttributeGroupByOutputType))]: GetScalarType<T[P], AttributeGroupByOutputType[P]>
    }
  >>
    

  export type AttributeSelect = {
    id?: boolean
    values?: boolean | AttributeValuesFindManyArgs
  }

  export type AttributeInclude = {
    values?: boolean | AttributeValuesFindManyArgs
  }

  export type AttributeGetPayload<
    S extends boolean | null | undefined | AttributeArgs,
    U = keyof S
      > = S extends true
        ? Attribute
    : S extends undefined
    ? never
    : S extends AttributeArgs | AttributeFindManyArgs
    ?'include' extends U
    ? Attribute  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'values'
        ? Array < AttributeValuesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Attribute ?Attribute [P]
  : 
          P extends 'values'
        ? Array < AttributeValuesGetPayload<S['select'][P]>>  : never
  } 
    : Attribute
  : Attribute


  type AttributeCountArgs = Merge<
    Omit<AttributeFindManyArgs, 'select' | 'include'> & {
      select?: AttributeCountAggregateInputType | true
    }
  >

  export interface AttributeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Attribute that matches the filter.
     * @param {AttributeFindUniqueArgs} args - Arguments to find a Attribute
     * @example
     * // Get one Attribute
     * const attribute = await prisma.attribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttributeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttributeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Attribute'> extends True ? CheckSelect<T, Prisma__AttributeClient<Attribute>, Prisma__AttributeClient<AttributeGetPayload<T>>> : CheckSelect<T, Prisma__AttributeClient<Attribute | null >, Prisma__AttributeClient<AttributeGetPayload<T> | null >>

    /**
     * Find the first Attribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeFindFirstArgs} args - Arguments to find a Attribute
     * @example
     * // Get one Attribute
     * const attribute = await prisma.attribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttributeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttributeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Attribute'> extends True ? CheckSelect<T, Prisma__AttributeClient<Attribute>, Prisma__AttributeClient<AttributeGetPayload<T>>> : CheckSelect<T, Prisma__AttributeClient<Attribute | null >, Prisma__AttributeClient<AttributeGetPayload<T> | null >>

    /**
     * Find zero or more Attributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attributes
     * const attributes = await prisma.attribute.findMany()
     * 
     * // Get first 10 Attributes
     * const attributes = await prisma.attribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attributeWithIdOnly = await prisma.attribute.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttributeFindManyArgs>(
      args?: SelectSubset<T, AttributeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Attribute>>, PrismaPromise<Array<AttributeGetPayload<T>>>>

    /**
     * Create a Attribute.
     * @param {AttributeCreateArgs} args - Arguments to create a Attribute.
     * @example
     * // Create one Attribute
     * const Attribute = await prisma.attribute.create({
     *   data: {
     *     // ... data to create a Attribute
     *   }
     * })
     * 
    **/
    create<T extends AttributeCreateArgs>(
      args: SelectSubset<T, AttributeCreateArgs>
    ): CheckSelect<T, Prisma__AttributeClient<Attribute>, Prisma__AttributeClient<AttributeGetPayload<T>>>

    /**
     * Create many Attributes.
     *     @param {AttributeCreateManyArgs} args - Arguments to create many Attributes.
     *     @example
     *     // Create many Attributes
     *     const attribute = await prisma.attribute.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AttributeCreateManyArgs>(
      args?: SelectSubset<T, AttributeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Attribute.
     * @param {AttributeDeleteArgs} args - Arguments to delete one Attribute.
     * @example
     * // Delete one Attribute
     * const Attribute = await prisma.attribute.delete({
     *   where: {
     *     // ... filter to delete one Attribute
     *   }
     * })
     * 
    **/
    delete<T extends AttributeDeleteArgs>(
      args: SelectSubset<T, AttributeDeleteArgs>
    ): CheckSelect<T, Prisma__AttributeClient<Attribute>, Prisma__AttributeClient<AttributeGetPayload<T>>>

    /**
     * Update one Attribute.
     * @param {AttributeUpdateArgs} args - Arguments to update one Attribute.
     * @example
     * // Update one Attribute
     * const attribute = await prisma.attribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttributeUpdateArgs>(
      args: SelectSubset<T, AttributeUpdateArgs>
    ): CheckSelect<T, Prisma__AttributeClient<Attribute>, Prisma__AttributeClient<AttributeGetPayload<T>>>

    /**
     * Delete zero or more Attributes.
     * @param {AttributeDeleteManyArgs} args - Arguments to filter Attributes to delete.
     * @example
     * // Delete a few Attributes
     * const { count } = await prisma.attribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttributeDeleteManyArgs>(
      args?: SelectSubset<T, AttributeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attributes
     * const attribute = await prisma.attribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttributeUpdateManyArgs>(
      args: SelectSubset<T, AttributeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Attribute.
     * @param {AttributeUpsertArgs} args - Arguments to update or create a Attribute.
     * @example
     * // Update or create a Attribute
     * const attribute = await prisma.attribute.upsert({
     *   create: {
     *     // ... data to create a Attribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attribute we want to update
     *   }
     * })
    **/
    upsert<T extends AttributeUpsertArgs>(
      args: SelectSubset<T, AttributeUpsertArgs>
    ): CheckSelect<T, Prisma__AttributeClient<Attribute>, Prisma__AttributeClient<AttributeGetPayload<T>>>

    /**
     * Count the number of Attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeCountArgs} args - Arguments to filter Attributes to count.
     * @example
     * // Count the number of Attributes
     * const count = await prisma.attribute.count({
     *   where: {
     *     // ... the filter for the Attributes we want to count
     *   }
     * })
    **/
    count<T extends AttributeCountArgs>(
      args?: Subset<T, AttributeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttributeAggregateArgs>(args: Subset<T, AttributeAggregateArgs>): PrismaPromise<GetAttributeAggregateType<T>>

    /**
     * Group by Attribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttributeGroupByArgs['orderBy'] }
        : { orderBy?: AttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttributeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttributeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    values<T extends AttributeValuesFindManyArgs = {}>(args?: Subset<T, AttributeValuesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AttributeValues>>, PrismaPromise<Array<AttributeValuesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Attribute findUnique
   */
  export type AttributeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Attribute
    **/
    select?: AttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeInclude | null
    /**
     * Throw an Error if a Attribute can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Attribute to fetch.
    **/
    where: AttributeWhereUniqueInput
  }


  /**
   * Attribute findFirst
   */
  export type AttributeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Attribute
    **/
    select?: AttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeInclude | null
    /**
     * Throw an Error if a Attribute can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Attribute to fetch.
    **/
    where?: AttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attributes to fetch.
    **/
    orderBy?: Enumerable<AttributeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attributes.
    **/
    cursor?: AttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attributes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attributes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attributes.
    **/
    distinct?: Enumerable<AttributeScalarFieldEnum>
  }


  /**
   * Attribute findMany
   */
  export type AttributeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Attribute
    **/
    select?: AttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeInclude | null
    /**
     * Filter, which Attributes to fetch.
    **/
    where?: AttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attributes to fetch.
    **/
    orderBy?: Enumerable<AttributeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attributes.
    **/
    cursor?: AttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attributes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attributes.
    **/
    skip?: number
    distinct?: Enumerable<AttributeScalarFieldEnum>
  }


  /**
   * Attribute create
   */
  export type AttributeCreateArgs = {
    /**
     * Select specific fields to fetch from the Attribute
    **/
    select?: AttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeInclude | null
    /**
     * The data needed to create a Attribute.
    **/
    data: XOR<AttributeCreateInput, AttributeUncheckedCreateInput>
  }


  /**
   * Attribute createMany
   */
  export type AttributeCreateManyArgs = {
    data: Enumerable<AttributeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Attribute update
   */
  export type AttributeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Attribute
    **/
    select?: AttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeInclude | null
    /**
     * The data needed to update a Attribute.
    **/
    data: XOR<AttributeUpdateInput, AttributeUncheckedUpdateInput>
    /**
     * Choose, which Attribute to update.
    **/
    where: AttributeWhereUniqueInput
  }


  /**
   * Attribute updateMany
   */
  export type AttributeUpdateManyArgs = {
    data: XOR<AttributeUpdateManyMutationInput, AttributeUncheckedUpdateManyInput>
    where?: AttributeWhereInput
  }


  /**
   * Attribute upsert
   */
  export type AttributeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Attribute
    **/
    select?: AttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeInclude | null
    /**
     * The filter to search for the Attribute to update in case it exists.
    **/
    where: AttributeWhereUniqueInput
    /**
     * In case the Attribute found by the `where` argument doesn't exist, create a new Attribute with this data.
    **/
    create: XOR<AttributeCreateInput, AttributeUncheckedCreateInput>
    /**
     * In case the Attribute was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AttributeUpdateInput, AttributeUncheckedUpdateInput>
  }


  /**
   * Attribute delete
   */
  export type AttributeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Attribute
    **/
    select?: AttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeInclude | null
    /**
     * Filter which Attribute to delete.
    **/
    where: AttributeWhereUniqueInput
  }


  /**
   * Attribute deleteMany
   */
  export type AttributeDeleteManyArgs = {
    where?: AttributeWhereInput
  }


  /**
   * Attribute without action
   */
  export type AttributeArgs = {
    /**
     * Select specific fields to fetch from the Attribute
    **/
    select?: AttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeInclude | null
  }



  /**
   * Model AttributeValues
   */


  export type AggregateAttributeValues = {
    count: AttributeValuesCountAggregateOutputType | null
    avg: AttributeValuesAvgAggregateOutputType | null
    sum: AttributeValuesSumAggregateOutputType | null
    min: AttributeValuesMinAggregateOutputType | null
    max: AttributeValuesMaxAggregateOutputType | null
  }

  export type AttributeValuesAvgAggregateOutputType = {
    id: number | null
    attributeId: number | null
    value: number | null
  }

  export type AttributeValuesSumAggregateOutputType = {
    id: number | null
    attributeId: number | null
    value: number | null
  }

  export type AttributeValuesMinAggregateOutputType = {
    id: number | null
    attributeId: number | null
    value: number | null
  }

  export type AttributeValuesMaxAggregateOutputType = {
    id: number | null
    attributeId: number | null
    value: number | null
  }

  export type AttributeValuesCountAggregateOutputType = {
    id: number
    attributeId: number
    value: number
    _all: number
  }


  export type AttributeValuesAvgAggregateInputType = {
    id?: true
    attributeId?: true
    value?: true
  }

  export type AttributeValuesSumAggregateInputType = {
    id?: true
    attributeId?: true
    value?: true
  }

  export type AttributeValuesMinAggregateInputType = {
    id?: true
    attributeId?: true
    value?: true
  }

  export type AttributeValuesMaxAggregateInputType = {
    id?: true
    attributeId?: true
    value?: true
  }

  export type AttributeValuesCountAggregateInputType = {
    id?: true
    attributeId?: true
    value?: true
    _all?: true
  }

  export type AttributeValuesAggregateArgs = {
    /**
     * Filter which AttributeValues to aggregate.
    **/
    where?: AttributeValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttributeValues to fetch.
    **/
    orderBy?: Enumerable<AttributeValuesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AttributeValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttributeValues from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttributeValues.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttributeValues
    **/
    count?: true | AttributeValuesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AttributeValuesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AttributeValuesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AttributeValuesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AttributeValuesMaxAggregateInputType
  }

  export type GetAttributeValuesAggregateType<T extends AttributeValuesAggregateArgs> = {
    [P in keyof T & keyof AggregateAttributeValues]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttributeValues[P]>
      : GetScalarType<T[P], AggregateAttributeValues[P]>
  }


    
    
  export type AttributeValuesGroupByArgs = {
    where?: AttributeValuesWhereInput
    orderBy?: Enumerable<AttributeValuesOrderByInput>
    by: Array<AttributeValuesScalarFieldEnum>
    having?: AttributeValuesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: AttributeValuesCountAggregateInputType | true
    avg?: AttributeValuesAvgAggregateInputType
    sum?: AttributeValuesSumAggregateInputType
    min?: AttributeValuesMinAggregateInputType
    max?: AttributeValuesMaxAggregateInputType
  }


  export type AttributeValuesGroupByOutputType = {
    id: number
    attributeId: number
    value: number
    count: AttributeValuesCountAggregateOutputType | null
    avg: AttributeValuesAvgAggregateOutputType | null
    sum: AttributeValuesSumAggregateOutputType | null
    min: AttributeValuesMinAggregateOutputType | null
    max: AttributeValuesMaxAggregateOutputType | null
  }

  type GetAttributeValuesGroupByPayload<T extends AttributeValuesGroupByArgs> = Promise<Array<
    PickArray<AttributeValuesGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof AttributeValuesGroupByOutputType))]: GetScalarType<T[P], AttributeValuesGroupByOutputType[P]>
    }
  >>
    

  export type AttributeValuesSelect = {
    id?: boolean
    attributeId?: boolean
    value?: boolean
    attribute?: boolean | AttributeArgs
  }

  export type AttributeValuesInclude = {
    attribute?: boolean | AttributeArgs
  }

  export type AttributeValuesGetPayload<
    S extends boolean | null | undefined | AttributeValuesArgs,
    U = keyof S
      > = S extends true
        ? AttributeValues
    : S extends undefined
    ? never
    : S extends AttributeValuesArgs | AttributeValuesFindManyArgs
    ?'include' extends U
    ? AttributeValues  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'attribute'
        ? AttributeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AttributeValues ?AttributeValues [P]
  : 
          P extends 'attribute'
        ? AttributeGetPayload<S['select'][P]> : never
  } 
    : AttributeValues
  : AttributeValues


  type AttributeValuesCountArgs = Merge<
    Omit<AttributeValuesFindManyArgs, 'select' | 'include'> & {
      select?: AttributeValuesCountAggregateInputType | true
    }
  >

  export interface AttributeValuesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AttributeValues that matches the filter.
     * @param {AttributeValuesFindUniqueArgs} args - Arguments to find a AttributeValues
     * @example
     * // Get one AttributeValues
     * const attributeValues = await prisma.attributeValues.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttributeValuesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttributeValuesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AttributeValues'> extends True ? CheckSelect<T, Prisma__AttributeValuesClient<AttributeValues>, Prisma__AttributeValuesClient<AttributeValuesGetPayload<T>>> : CheckSelect<T, Prisma__AttributeValuesClient<AttributeValues | null >, Prisma__AttributeValuesClient<AttributeValuesGetPayload<T> | null >>

    /**
     * Find the first AttributeValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeValuesFindFirstArgs} args - Arguments to find a AttributeValues
     * @example
     * // Get one AttributeValues
     * const attributeValues = await prisma.attributeValues.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttributeValuesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttributeValuesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AttributeValues'> extends True ? CheckSelect<T, Prisma__AttributeValuesClient<AttributeValues>, Prisma__AttributeValuesClient<AttributeValuesGetPayload<T>>> : CheckSelect<T, Prisma__AttributeValuesClient<AttributeValues | null >, Prisma__AttributeValuesClient<AttributeValuesGetPayload<T> | null >>

    /**
     * Find zero or more AttributeValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeValuesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttributeValues
     * const attributeValues = await prisma.attributeValues.findMany()
     * 
     * // Get first 10 AttributeValues
     * const attributeValues = await prisma.attributeValues.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attributeValuesWithIdOnly = await prisma.attributeValues.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttributeValuesFindManyArgs>(
      args?: SelectSubset<T, AttributeValuesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AttributeValues>>, PrismaPromise<Array<AttributeValuesGetPayload<T>>>>

    /**
     * Create a AttributeValues.
     * @param {AttributeValuesCreateArgs} args - Arguments to create a AttributeValues.
     * @example
     * // Create one AttributeValues
     * const AttributeValues = await prisma.attributeValues.create({
     *   data: {
     *     // ... data to create a AttributeValues
     *   }
     * })
     * 
    **/
    create<T extends AttributeValuesCreateArgs>(
      args: SelectSubset<T, AttributeValuesCreateArgs>
    ): CheckSelect<T, Prisma__AttributeValuesClient<AttributeValues>, Prisma__AttributeValuesClient<AttributeValuesGetPayload<T>>>

    /**
     * Create many AttributeValues.
     *     @param {AttributeValuesCreateManyArgs} args - Arguments to create many AttributeValues.
     *     @example
     *     // Create many AttributeValues
     *     const attributeValues = await prisma.attributeValues.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AttributeValuesCreateManyArgs>(
      args?: SelectSubset<T, AttributeValuesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AttributeValues.
     * @param {AttributeValuesDeleteArgs} args - Arguments to delete one AttributeValues.
     * @example
     * // Delete one AttributeValues
     * const AttributeValues = await prisma.attributeValues.delete({
     *   where: {
     *     // ... filter to delete one AttributeValues
     *   }
     * })
     * 
    **/
    delete<T extends AttributeValuesDeleteArgs>(
      args: SelectSubset<T, AttributeValuesDeleteArgs>
    ): CheckSelect<T, Prisma__AttributeValuesClient<AttributeValues>, Prisma__AttributeValuesClient<AttributeValuesGetPayload<T>>>

    /**
     * Update one AttributeValues.
     * @param {AttributeValuesUpdateArgs} args - Arguments to update one AttributeValues.
     * @example
     * // Update one AttributeValues
     * const attributeValues = await prisma.attributeValues.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttributeValuesUpdateArgs>(
      args: SelectSubset<T, AttributeValuesUpdateArgs>
    ): CheckSelect<T, Prisma__AttributeValuesClient<AttributeValues>, Prisma__AttributeValuesClient<AttributeValuesGetPayload<T>>>

    /**
     * Delete zero or more AttributeValues.
     * @param {AttributeValuesDeleteManyArgs} args - Arguments to filter AttributeValues to delete.
     * @example
     * // Delete a few AttributeValues
     * const { count } = await prisma.attributeValues.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttributeValuesDeleteManyArgs>(
      args?: SelectSubset<T, AttributeValuesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttributeValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeValuesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttributeValues
     * const attributeValues = await prisma.attributeValues.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttributeValuesUpdateManyArgs>(
      args: SelectSubset<T, AttributeValuesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AttributeValues.
     * @param {AttributeValuesUpsertArgs} args - Arguments to update or create a AttributeValues.
     * @example
     * // Update or create a AttributeValues
     * const attributeValues = await prisma.attributeValues.upsert({
     *   create: {
     *     // ... data to create a AttributeValues
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttributeValues we want to update
     *   }
     * })
    **/
    upsert<T extends AttributeValuesUpsertArgs>(
      args: SelectSubset<T, AttributeValuesUpsertArgs>
    ): CheckSelect<T, Prisma__AttributeValuesClient<AttributeValues>, Prisma__AttributeValuesClient<AttributeValuesGetPayload<T>>>

    /**
     * Count the number of AttributeValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeValuesCountArgs} args - Arguments to filter AttributeValues to count.
     * @example
     * // Count the number of AttributeValues
     * const count = await prisma.attributeValues.count({
     *   where: {
     *     // ... the filter for the AttributeValues we want to count
     *   }
     * })
    **/
    count<T extends AttributeValuesCountArgs>(
      args?: Subset<T, AttributeValuesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttributeValuesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttributeValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeValuesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttributeValuesAggregateArgs>(args: Subset<T, AttributeValuesAggregateArgs>): PrismaPromise<GetAttributeValuesAggregateType<T>>

    /**
     * Group by AttributeValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeValuesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttributeValuesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttributeValuesGroupByArgs['orderBy'] }
        : { orderBy?: AttributeValuesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttributeValuesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttributeValuesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttributeValues.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttributeValuesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    attribute<T extends AttributeArgs = {}>(args?: Subset<T, AttributeArgs>): CheckSelect<T, Prisma__AttributeClient<Attribute | null >, Prisma__AttributeClient<AttributeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AttributeValues findUnique
   */
  export type AttributeValuesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AttributeValues
    **/
    select?: AttributeValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeValuesInclude | null
    /**
     * Throw an Error if a AttributeValues can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AttributeValues to fetch.
    **/
    where: AttributeValuesWhereUniqueInput
  }


  /**
   * AttributeValues findFirst
   */
  export type AttributeValuesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AttributeValues
    **/
    select?: AttributeValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeValuesInclude | null
    /**
     * Throw an Error if a AttributeValues can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AttributeValues to fetch.
    **/
    where?: AttributeValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttributeValues to fetch.
    **/
    orderBy?: Enumerable<AttributeValuesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttributeValues.
    **/
    cursor?: AttributeValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttributeValues from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttributeValues.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttributeValues.
    **/
    distinct?: Enumerable<AttributeValuesScalarFieldEnum>
  }


  /**
   * AttributeValues findMany
   */
  export type AttributeValuesFindManyArgs = {
    /**
     * Select specific fields to fetch from the AttributeValues
    **/
    select?: AttributeValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeValuesInclude | null
    /**
     * Filter, which AttributeValues to fetch.
    **/
    where?: AttributeValuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttributeValues to fetch.
    **/
    orderBy?: Enumerable<AttributeValuesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttributeValues.
    **/
    cursor?: AttributeValuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttributeValues from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttributeValues.
    **/
    skip?: number
    distinct?: Enumerable<AttributeValuesScalarFieldEnum>
  }


  /**
   * AttributeValues create
   */
  export type AttributeValuesCreateArgs = {
    /**
     * Select specific fields to fetch from the AttributeValues
    **/
    select?: AttributeValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeValuesInclude | null
    /**
     * The data needed to create a AttributeValues.
    **/
    data: XOR<AttributeValuesCreateInput, AttributeValuesUncheckedCreateInput>
  }


  /**
   * AttributeValues createMany
   */
  export type AttributeValuesCreateManyArgs = {
    data: Enumerable<AttributeValuesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AttributeValues update
   */
  export type AttributeValuesUpdateArgs = {
    /**
     * Select specific fields to fetch from the AttributeValues
    **/
    select?: AttributeValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeValuesInclude | null
    /**
     * The data needed to update a AttributeValues.
    **/
    data: XOR<AttributeValuesUpdateInput, AttributeValuesUncheckedUpdateInput>
    /**
     * Choose, which AttributeValues to update.
    **/
    where: AttributeValuesWhereUniqueInput
  }


  /**
   * AttributeValues updateMany
   */
  export type AttributeValuesUpdateManyArgs = {
    data: XOR<AttributeValuesUpdateManyMutationInput, AttributeValuesUncheckedUpdateManyInput>
    where?: AttributeValuesWhereInput
  }


  /**
   * AttributeValues upsert
   */
  export type AttributeValuesUpsertArgs = {
    /**
     * Select specific fields to fetch from the AttributeValues
    **/
    select?: AttributeValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeValuesInclude | null
    /**
     * The filter to search for the AttributeValues to update in case it exists.
    **/
    where: AttributeValuesWhereUniqueInput
    /**
     * In case the AttributeValues found by the `where` argument doesn't exist, create a new AttributeValues with this data.
    **/
    create: XOR<AttributeValuesCreateInput, AttributeValuesUncheckedCreateInput>
    /**
     * In case the AttributeValues was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AttributeValuesUpdateInput, AttributeValuesUncheckedUpdateInput>
  }


  /**
   * AttributeValues delete
   */
  export type AttributeValuesDeleteArgs = {
    /**
     * Select specific fields to fetch from the AttributeValues
    **/
    select?: AttributeValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeValuesInclude | null
    /**
     * Filter which AttributeValues to delete.
    **/
    where: AttributeValuesWhereUniqueInput
  }


  /**
   * AttributeValues deleteMany
   */
  export type AttributeValuesDeleteManyArgs = {
    where?: AttributeValuesWhereInput
  }


  /**
   * AttributeValues without action
   */
  export type AttributeValuesArgs = {
    /**
     * Select specific fields to fetch from the AttributeValues
    **/
    select?: AttributeValuesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AttributeValuesInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    password: 'password',
    phone: 'phone',
    countyId: 'countyId',
    zip: 'zip',
    isPrivacyEneable: 'isPrivacyEneable',
    role: 'role',
    languageId: 'languageId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const CountyScalarFieldEnum: {
    id: 'id',
    cityId: 'cityId',
    name: 'name'
  };

  export type CountyScalarFieldEnum = (typeof CountyScalarFieldEnum)[keyof typeof CountyScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    stateId: 'stateId',
    name: 'name'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const StateScalarFieldEnum: {
    id: 'id',
    countryId: 'countryId',
    name: 'name'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    currencyId: 'currencyId',
    name: 'name'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    exchangeRate: 'exchangeRate'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    currencyId: 'currencyId',
    method: 'method',
    status: 'status'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    name: 'name',
    maxImgs: 'maxImgs',
    postValidityIntervalInDays: 'postValidityIntervalInDays'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    unit: 'unit',
    isMandatory: 'isMandatory',
    screenControlId: 'screenControlId'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const PossibleValuesScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    value: 'value'
  };

  export type PossibleValuesScalarFieldEnum = (typeof PossibleValuesScalarFieldEnum)[keyof typeof PossibleValuesScalarFieldEnum]


  export const ScreenControlScalarFieldEnum: {
    id: 'id',
    screenControl: 'screenControl'
  };

  export type ScreenControlScalarFieldEnum = (typeof ScreenControlScalarFieldEnum)[keyof typeof ScreenControlScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    lastRenewedAt: 'lastRenewedAt',
    title: 'title',
    detail: 'detail',
    isActive: 'isActive',
    isSeller: 'isSeller',
    isIndividual: 'isIndividual',
    expectedPrice: 'expectedPrice',
    isPriceNegotiable: 'isPriceNegotiable'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    name: 'name',
    url: 'url'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const AttributeScalarFieldEnum: {
    id: 'id'
  };

  export type AttributeScalarFieldEnum = (typeof AttributeScalarFieldEnum)[keyof typeof AttributeScalarFieldEnum]


  export const AttributeValuesScalarFieldEnum: {
    id: 'id',
    attributeId: 'attributeId',
    value: 'value'
  };

  export type AttributeValuesScalarFieldEnum = (typeof AttributeValuesScalarFieldEnum)[keyof typeof AttributeValuesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    password?: StringFilter | string
    phone?: StringFilter | string
    countyId?: IntFilter | number
    zip?: StringFilter | string
    isPrivacyEneable?: BoolFilter | boolean
    role?: EnumRoleFilter | Role
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
    languageId?: IntFilter | number
    posts?: PostListRelationFilter
  }

  export type UserOrderByInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    countyId?: SortOrder
    zip?: SortOrder
    isPrivacyEneable?: SortOrder
    role?: SortOrder
    languageId?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
    phone?: string
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    countyId?: IntWithAggregatesFilter | number
    zip?: StringWithAggregatesFilter | string
    isPrivacyEneable?: BoolWithAggregatesFilter | boolean
    role?: EnumRoleWithAggregatesFilter | Role
    languageId?: IntWithAggregatesFilter | number
  }

  export type LanguageWhereInput = {
    AND?: Enumerable<LanguageWhereInput>
    OR?: Enumerable<LanguageWhereInput>
    NOT?: Enumerable<LanguageWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    User?: UserListRelationFilter
  }

  export type LanguageOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageWhereUniqueInput = {
    id?: number
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LanguageScalarWhereWithAggregatesInput>
    OR?: Enumerable<LanguageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LanguageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type CountyWhereInput = {
    AND?: Enumerable<CountyWhereInput>
    OR?: Enumerable<CountyWhereInput>
    NOT?: Enumerable<CountyWhereInput>
    id?: IntFilter | number
    cityId?: IntFilter | number
    name?: StringFilter | string
    city?: XOR<CityRelationFilter, CityWhereInput>
  }

  export type CountyOrderByInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
  }

  export type CountyWhereUniqueInput = {
    id?: number
  }

  export type CountyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountyScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    cityId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type CityWhereInput = {
    AND?: Enumerable<CityWhereInput>
    OR?: Enumerable<CityWhereInput>
    NOT?: Enumerable<CityWhereInput>
    id?: IntFilter | number
    stateId?: IntFilter | number
    name?: StringFilter | string
    state?: XOR<StateRelationFilter, StateWhereInput>
    counties?: CountyListRelationFilter
  }

  export type CityOrderByInput = {
    id?: SortOrder
    stateId?: SortOrder
    name?: SortOrder
  }

  export type CityWhereUniqueInput = {
    id?: number
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CityScalarWhereWithAggregatesInput>
    OR?: Enumerable<CityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    stateId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type StateWhereInput = {
    AND?: Enumerable<StateWhereInput>
    OR?: Enumerable<StateWhereInput>
    NOT?: Enumerable<StateWhereInput>
    id?: IntFilter | number
    countryId?: IntFilter | number
    name?: StringFilter | string
    cities?: CityListRelationFilter
    country?: XOR<CountryRelationFilter, CountryWhereInput>
  }

  export type StateOrderByInput = {
    id?: SortOrder
    countryId?: SortOrder
    name?: SortOrder
  }

  export type StateWhereUniqueInput = {
    id?: number
  }

  export type StateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StateScalarWhereWithAggregatesInput>
    OR?: Enumerable<StateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StateScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    countryId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type CountryWhereInput = {
    AND?: Enumerable<CountryWhereInput>
    OR?: Enumerable<CountryWhereInput>
    NOT?: Enumerable<CountryWhereInput>
    id?: IntFilter | number
    currencyId?: IntFilter | number
    name?: StringFilter | string
    currency?: XOR<CurrencyRelationFilter, CurrencyWhereInput>
    states?: StateListRelationFilter
  }

  export type CountryOrderByInput = {
    id?: SortOrder
    currencyId?: SortOrder
    name?: SortOrder
  }

  export type CountryWhereUniqueInput = {
    id?: number
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    currencyId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type CurrencyWhereInput = {
    AND?: Enumerable<CurrencyWhereInput>
    OR?: Enumerable<CurrencyWhereInput>
    NOT?: Enumerable<CurrencyWhereInput>
    id?: IntFilter | number
    code?: StringFilter | string
    exchangeRate?: FloatFilter | number
    Payment?: PaymentListRelationFilter
    countries?: CountryListRelationFilter
  }

  export type CurrencyOrderByInput = {
    id?: SortOrder
    code?: SortOrder
    exchangeRate?: SortOrder
  }

  export type CurrencyWhereUniqueInput = {
    id?: number
    code?: string
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CurrencyScalarWhereWithAggregatesInput>
    OR?: Enumerable<CurrencyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CurrencyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    code?: StringWithAggregatesFilter | string
    exchangeRate?: FloatWithAggregatesFilter | number
  }

  export type PaymentWhereInput = {
    AND?: Enumerable<PaymentWhereInput>
    OR?: Enumerable<PaymentWhereInput>
    NOT?: Enumerable<PaymentWhereInput>
    id?: IntFilter | number
    currencyId?: IntFilter | number
    method?: StringFilter | string
    status?: StringFilter | string
    currency?: XOR<CurrencyRelationFilter, CurrencyWhereInput>
  }

  export type PaymentOrderByInput = {
    id?: SortOrder
    currencyId?: SortOrder
    method?: SortOrder
    status?: SortOrder
  }

  export type PaymentWhereUniqueInput = {
    id?: number
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    currencyId?: IntWithAggregatesFilter | number
    method?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: IntFilter | number
    parentId?: IntNullableFilter | number | null
    name?: StringFilter | string
    maxImgs?: IntFilter | number
    postValidityIntervalInDays?: IntNullableFilter | number | null
    children?: CategoryListRelationFilter
    parent?: XOR<CategoryRelationFilter, CategoryWhereInput> | null
    posts?: PostListRelationFilter
    properties?: PropertyListRelationFilter
  }

  export type CategoryOrderByInput = {
    id?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    maxImgs?: SortOrder
    postValidityIntervalInDays?: SortOrder
  }

  export type CategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    parentId?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    maxImgs?: IntWithAggregatesFilter | number
    postValidityIntervalInDays?: IntNullableWithAggregatesFilter | number | null
  }

  export type PropertyWhereInput = {
    AND?: Enumerable<PropertyWhereInput>
    OR?: Enumerable<PropertyWhereInput>
    NOT?: Enumerable<PropertyWhereInput>
    id?: IntFilter | number
    categoryId?: IntFilter | number
    name?: StringFilter | string
    unit?: StringFilter | string
    isMandatory?: BoolFilter | boolean
    values?: PossibleValuesListRelationFilter
    screenControlId?: IntFilter | number
    screenControl?: XOR<ScreenControlRelationFilter, ScreenControlWhereInput>
    Category?: XOR<CategoryRelationFilter, CategoryWhereInput> | null
  }

  export type PropertyOrderByInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    isMandatory?: SortOrder
    screenControlId?: SortOrder
  }

  export type PropertyWhereUniqueInput = {
    id?: number
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PropertyScalarWhereWithAggregatesInput>
    OR?: Enumerable<PropertyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PropertyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    categoryId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    unit?: StringWithAggregatesFilter | string
    isMandatory?: BoolWithAggregatesFilter | boolean
    screenControlId?: IntWithAggregatesFilter | number
  }

  export type PossibleValuesWhereInput = {
    AND?: Enumerable<PossibleValuesWhereInput>
    OR?: Enumerable<PossibleValuesWhereInput>
    NOT?: Enumerable<PossibleValuesWhereInput>
    id?: IntFilter | number
    propertyId?: IntFilter | number
    value?: IntFilter | number
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }

  export type PossibleValuesOrderByInput = {
    id?: SortOrder
    propertyId?: SortOrder
    value?: SortOrder
  }

  export type PossibleValuesWhereUniqueInput = {
    id?: number
  }

  export type PossibleValuesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PossibleValuesScalarWhereWithAggregatesInput>
    OR?: Enumerable<PossibleValuesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PossibleValuesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    propertyId?: IntWithAggregatesFilter | number
    value?: IntWithAggregatesFilter | number
  }

  export type ScreenControlWhereInput = {
    AND?: Enumerable<ScreenControlWhereInput>
    OR?: Enumerable<ScreenControlWhereInput>
    NOT?: Enumerable<ScreenControlWhereInput>
    id?: IntFilter | number
    screenControl?: StringFilter | string
    Property?: PropertyListRelationFilter
  }

  export type ScreenControlOrderByInput = {
    id?: SortOrder
    screenControl?: SortOrder
  }

  export type ScreenControlWhereUniqueInput = {
    id?: number
  }

  export type ScreenControlScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ScreenControlScalarWhereWithAggregatesInput>
    OR?: Enumerable<ScreenControlScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ScreenControlScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    screenControl?: StringWithAggregatesFilter | string
  }

  export type PostWhereInput = {
    AND?: Enumerable<PostWhereInput>
    OR?: Enumerable<PostWhereInput>
    NOT?: Enumerable<PostWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    categoryId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    lastRenewedAt?: DateTimeFilter | Date | string
    title?: StringFilter | string
    detail?: StringFilter | string
    isActive?: BoolFilter | boolean
    isSeller?: BoolFilter | boolean
    isIndividual?: BoolFilter | boolean
    expectedPrice?: FloatNullableFilter | number | null
    isPriceNegotiable?: BoolFilter | boolean
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    images?: ImageListRelationFilter
  }

  export type PostOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    lastRenewedAt?: SortOrder
    title?: SortOrder
    detail?: SortOrder
    isActive?: SortOrder
    isSeller?: SortOrder
    isIndividual?: SortOrder
    expectedPrice?: SortOrder
    isPriceNegotiable?: SortOrder
  }

  export type PostWhereUniqueInput = {
    id?: number
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    categoryId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    lastRenewedAt?: DateTimeWithAggregatesFilter | Date | string
    title?: StringWithAggregatesFilter | string
    detail?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    isSeller?: BoolWithAggregatesFilter | boolean
    isIndividual?: BoolWithAggregatesFilter | boolean
    expectedPrice?: FloatNullableWithAggregatesFilter | number | null
    isPriceNegotiable?: BoolWithAggregatesFilter | boolean
  }

  export type ImageWhereInput = {
    AND?: Enumerable<ImageWhereInput>
    OR?: Enumerable<ImageWhereInput>
    NOT?: Enumerable<ImageWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    name?: StringFilter | string
    url?: StringFilter | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type ImageOrderByInput = {
    id?: SortOrder
    postId?: SortOrder
    name?: SortOrder
    url?: SortOrder
  }

  export type ImageWhereUniqueInput = {
    id?: number
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
  }

  export type AttributeWhereInput = {
    AND?: Enumerable<AttributeWhereInput>
    OR?: Enumerable<AttributeWhereInput>
    NOT?: Enumerable<AttributeWhereInput>
    id?: IntFilter | number
    values?: AttributeValuesListRelationFilter
  }

  export type AttributeOrderByInput = {
    id?: SortOrder
  }

  export type AttributeWhereUniqueInput = {
    id?: number
  }

  export type AttributeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AttributeScalarWhereWithAggregatesInput>
    OR?: Enumerable<AttributeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AttributeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type AttributeValuesWhereInput = {
    AND?: Enumerable<AttributeValuesWhereInput>
    OR?: Enumerable<AttributeValuesWhereInput>
    NOT?: Enumerable<AttributeValuesWhereInput>
    id?: IntFilter | number
    attributeId?: IntFilter | number
    value?: IntFilter | number
    attribute?: XOR<AttributeRelationFilter, AttributeWhereInput>
  }

  export type AttributeValuesOrderByInput = {
    id?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
  }

  export type AttributeValuesWhereUniqueInput = {
    id?: number
  }

  export type AttributeValuesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AttributeValuesScalarWhereWithAggregatesInput>
    OR?: Enumerable<AttributeValuesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AttributeValuesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    attributeId?: IntWithAggregatesFilter | number
    value?: IntWithAggregatesFilter | number
  }

  export type UserCreateInput = {
    email: string
    firstName: string
    lastName: string
    password: string
    phone: string
    countyId: number
    zip: string
    isPrivacyEneable?: boolean
    role?: Role
    language: LanguageCreateNestedOneWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    firstName: string
    lastName: string
    password: string
    phone: string
    countyId: number
    zip: string
    isPrivacyEneable?: boolean
    role?: Role
    languageId: number
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countyId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
    isPrivacyEneable?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | Role
    language?: LanguageUpdateOneRequiredWithoutUserInput
    posts?: PostUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countyId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
    isPrivacyEneable?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | Role
    languageId?: IntFieldUpdateOperationsInput | number
    posts?: PostUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    firstName: string
    lastName: string
    password: string
    phone: string
    countyId: number
    zip: string
    isPrivacyEneable?: boolean
    role?: Role
    languageId: number
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countyId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
    isPrivacyEneable?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countyId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
    isPrivacyEneable?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | Role
    languageId?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageCreateInput = {
    name: string
    User?: UserCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: number
    name: string
    User?: UserUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateManyWithoutLanguageInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutLanguageInput
  }

  export type LanguageCreateManyInput = {
    id?: number
    name: string
  }

  export type LanguageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountyCreateInput = {
    name: string
    city: CityCreateNestedOneWithoutCountiesInput
  }

  export type CountyUncheckedCreateInput = {
    id?: number
    cityId: number
    name: string
  }

  export type CountyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutCountiesInput
  }

  export type CountyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountyCreateManyInput = {
    id?: number
    cityId: number
    name: string
  }

  export type CountyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cityId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    name: string
    state: StateCreateNestedOneWithoutCitiesInput
    counties?: CountyCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: number
    stateId: number
    name: string
    counties?: CountyUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesInput
    counties?: CountyUpdateManyWithoutCityInput
  }

  export type CityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stateId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    counties?: CountyUncheckedUpdateManyWithoutCityInput
  }

  export type CityCreateManyInput = {
    id?: number
    stateId: number
    name: string
  }

  export type CityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stateId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StateCreateInput = {
    name: string
    cities?: CityCreateNestedManyWithoutStateInput
    country: CountryCreateNestedOneWithoutStatesInput
  }

  export type StateUncheckedCreateInput = {
    id?: number
    countryId: number
    name: string
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutStateInput
    country?: CountryUpdateOneRequiredWithoutStatesInput
  }

  export type StateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutStateInput
  }

  export type StateCreateManyInput = {
    id?: number
    countryId: number
    name: string
  }

  export type StateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCreateInput = {
    name: string
    currency: CurrencyCreateNestedOneWithoutCountriesInput
    states?: StateCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    currencyId: number
    name: string
    states?: StateUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    currency?: CurrencyUpdateOneRequiredWithoutCountriesInput
    states?: StateUpdateManyWithoutCountryInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    currencyId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    states?: StateUncheckedUpdateManyWithoutCountryInput
  }

  export type CountryCreateManyInput = {
    id?: number
    currencyId: number
    name: string
  }

  export type CountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    currencyId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyCreateInput = {
    code: string
    exchangeRate: number
    Payment?: PaymentCreateNestedManyWithoutCurrencyInput
    countries?: CountryCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateInput = {
    id?: number
    code: string
    exchangeRate: number
    Payment?: PaymentUncheckedCreateNestedManyWithoutCurrencyInput
    countries?: CountryUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    Payment?: PaymentUpdateManyWithoutCurrencyInput
    countries?: CountryUpdateManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    Payment?: PaymentUncheckedUpdateManyWithoutCurrencyInput
    countries?: CountryUncheckedUpdateManyWithoutCurrencyInput
  }

  export type CurrencyCreateManyInput = {
    id?: number
    code: string
    exchangeRate: number
  }

  export type CurrencyUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
  }

  export type CurrencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
  }

  export type PaymentCreateInput = {
    method: string
    status: string
    currency?: CurrencyCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    currencyId?: number
    method: string
    status: string
  }

  export type PaymentUpdateInput = {
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: CurrencyUpdateOneRequiredWithoutPaymentInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    currencyId?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    currencyId?: number
    method: string
    status: string
  }

  export type PaymentUpdateManyMutationInput = {
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    currencyId?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
    children?: CategoryCreateNestedManyWithoutParentInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    posts?: PostCreateNestedManyWithoutCategoryInput
    properties?: PropertyCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    parentId?: number | null
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    posts?: PostUncheckedCreateNestedManyWithoutCategoryInput
    properties?: PropertyUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
    children?: CategoryUpdateManyWithoutParentInput
    parent?: CategoryUpdateOneWithoutChildrenInput
    posts?: PostUpdateManyWithoutCategoryInput
    properties?: PropertyUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
    posts?: PostUncheckedUpdateManyWithoutCategoryInput
    properties?: PropertyUncheckedUpdateManyWithoutCategoryInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    parentId?: number | null
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyCreateInput = {
    name: string
    unit: string
    isMandatory: boolean
    values?: PossibleValuesCreateNestedManyWithoutPropertyInput
    screenControl: ScreenControlCreateNestedOneWithoutPropertyInput
    Category?: CategoryCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: number
    categoryId: number
    name: string
    unit: string
    isMandatory: boolean
    screenControlId: number
    values?: PossibleValuesUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    values?: PossibleValuesUpdateManyWithoutPropertyInput
    screenControl?: ScreenControlUpdateOneRequiredWithoutPropertyInput
    Category?: CategoryUpdateOneWithoutPropertiesInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    screenControlId?: IntFieldUpdateOperationsInput | number
    values?: PossibleValuesUncheckedUpdateManyWithoutPropertyInput
  }

  export type PropertyCreateManyInput = {
    id?: number
    categoryId: number
    name: string
    unit: string
    isMandatory: boolean
    screenControlId: number
  }

  export type PropertyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    screenControlId?: IntFieldUpdateOperationsInput | number
  }

  export type PossibleValuesCreateInput = {
    value: number
    property: PropertyCreateNestedOneWithoutValuesInput
  }

  export type PossibleValuesUncheckedCreateInput = {
    id?: number
    propertyId: number
    value: number
  }

  export type PossibleValuesUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    property?: PropertyUpdateOneRequiredWithoutValuesInput
  }

  export type PossibleValuesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type PossibleValuesCreateManyInput = {
    id?: number
    propertyId: number
    value: number
  }

  export type PossibleValuesUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
  }

  export type PossibleValuesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type ScreenControlCreateInput = {
    screenControl: string
    Property?: PropertyCreateNestedManyWithoutScreenControlInput
  }

  export type ScreenControlUncheckedCreateInput = {
    id?: number
    screenControl: string
    Property?: PropertyUncheckedCreateNestedManyWithoutScreenControlInput
  }

  export type ScreenControlUpdateInput = {
    screenControl?: StringFieldUpdateOperationsInput | string
    Property?: PropertyUpdateManyWithoutScreenControlInput
  }

  export type ScreenControlUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    screenControl?: StringFieldUpdateOperationsInput | string
    Property?: PropertyUncheckedUpdateManyWithoutScreenControlInput
  }

  export type ScreenControlCreateManyInput = {
    id?: number
    screenControl: string
  }

  export type ScreenControlUpdateManyMutationInput = {
    screenControl?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenControlUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    screenControl?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateInput = {
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
    category: CategoryCreateNestedOneWithoutPostsInput
    user: UserCreateNestedOneWithoutPostsInput
    images?: ImageCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    userId: number
    categoryId: number
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutPostsInput
    user?: UserUpdateOneRequiredWithoutPostsInput
    images?: ImageUpdateManyWithoutPostInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
    images?: ImageUncheckedUpdateManyWithoutPostInput
  }

  export type PostCreateManyInput = {
    id?: number
    userId: number
    categoryId: number
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
  }

  export type PostUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageCreateInput = {
    name: string
    url: string
    post: PostCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateInput = {
    id?: number
    postId: number
    name: string
    url: string
  }

  export type ImageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutImagesInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateManyInput = {
    id?: number
    postId: number
    name: string
    url: string
  }

  export type ImageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type AttributeCreateInput = {
    values?: AttributeValuesCreateNestedManyWithoutAttributeInput
  }

  export type AttributeUncheckedCreateInput = {
    id?: number
    values?: AttributeValuesUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type AttributeUpdateInput = {
    values?: AttributeValuesUpdateManyWithoutAttributeInput
  }

  export type AttributeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    values?: AttributeValuesUncheckedUpdateManyWithoutAttributeInput
  }

  export type AttributeCreateManyInput = {
    id?: number
  }

  export type AttributeUpdateManyMutationInput = {

  }

  export type AttributeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type AttributeValuesCreateInput = {
    value: number
    attribute: AttributeCreateNestedOneWithoutValuesInput
  }

  export type AttributeValuesUncheckedCreateInput = {
    id?: number
    attributeId: number
    value: number
  }

  export type AttributeValuesUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    attribute?: AttributeUpdateOneRequiredWithoutValuesInput
  }

  export type AttributeValuesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type AttributeValuesCreateManyInput = {
    id?: number
    attributeId: number
    value: number
  }

  export type AttributeValuesUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
  }

  export type AttributeValuesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type LanguageRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    count?: NestedIntFilter
    min?: NestedBoolFilter
    max?: NestedBoolFilter
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    count?: NestedIntFilter
    min?: NestedEnumRoleFilter
    max?: NestedEnumRoleFilter
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type StateRelationFilter = {
    is?: StateWhereInput
    isNot?: StateWhereInput
  }

  export type CountyListRelationFilter = {
    every?: CountyWhereInput
    some?: CountyWhereInput
    none?: CountyWhereInput
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type CurrencyRelationFilter = {
    is?: CurrencyWhereInput
    isNot?: CurrencyWhereInput
  }

  export type StateListRelationFilter = {
    every?: StateWhereInput
    some?: StateWhereInput
    none?: StateWhereInput
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type CountryListRelationFilter = {
    every?: CountryWhereInput
    some?: CountryWhereInput
    none?: CountryWhereInput
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedFloatFilter
    min?: NestedFloatFilter
    max?: NestedFloatFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedIntNullableFilter
    min?: NestedIntNullableFilter
    max?: NestedIntNullableFilter
  }

  export type PossibleValuesListRelationFilter = {
    every?: PossibleValuesWhereInput
    some?: PossibleValuesWhereInput
    none?: PossibleValuesWhereInput
  }

  export type ScreenControlRelationFilter = {
    is?: ScreenControlWhereInput
    isNot?: ScreenControlWhereInput
  }

  export type PropertyRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedFloatNullableFilter
    min?: NestedFloatNullableFilter
    max?: NestedFloatNullableFilter
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type AttributeValuesListRelationFilter = {
    every?: AttributeValuesWhereInput
    some?: AttributeValuesWhereInput
    none?: AttributeValuesWhereInput
  }

  export type AttributeRelationFilter = {
    is?: AttributeWhereInput
    isNot?: AttributeWhereInput
  }

  export type LanguageCreateNestedOneWithoutUserInput = {
    create?: XOR<LanguageCreateWithoutUserInput, LanguageUncheckedCreateWithoutUserInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutUserInput
    connect?: LanguageWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type LanguageUpdateOneRequiredWithoutUserInput = {
    create?: XOR<LanguageCreateWithoutUserInput, LanguageUncheckedCreateWithoutUserInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutUserInput
    upsert?: LanguageUpsertWithoutUserInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<LanguageUpdateWithoutUserInput, LanguageUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type UserCreateNestedManyWithoutLanguageInput = {
    create?: XOR<Enumerable<UserCreateWithoutLanguageInput>, Enumerable<UserUncheckedCreateWithoutLanguageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLanguageInput>
    createMany?: UserCreateManyLanguageInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<Enumerable<UserCreateWithoutLanguageInput>, Enumerable<UserUncheckedCreateWithoutLanguageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLanguageInput>
    createMany?: UserCreateManyLanguageInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUpdateManyWithoutLanguageInput = {
    create?: XOR<Enumerable<UserCreateWithoutLanguageInput>, Enumerable<UserUncheckedCreateWithoutLanguageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLanguageInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutLanguageInput>
    createMany?: UserCreateManyLanguageInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutLanguageInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutLanguageInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutLanguageInput = {
    create?: XOR<Enumerable<UserCreateWithoutLanguageInput>, Enumerable<UserUncheckedCreateWithoutLanguageInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLanguageInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutLanguageInput>
    createMany?: UserCreateManyLanguageInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutLanguageInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutLanguageInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type CityCreateNestedOneWithoutCountiesInput = {
    create?: XOR<CityCreateWithoutCountiesInput, CityUncheckedCreateWithoutCountiesInput>
    connectOrCreate?: CityCreateOrConnectWithoutCountiesInput
    connect?: CityWhereUniqueInput
  }

  export type CityUpdateOneRequiredWithoutCountiesInput = {
    create?: XOR<CityCreateWithoutCountiesInput, CityUncheckedCreateWithoutCountiesInput>
    connectOrCreate?: CityCreateOrConnectWithoutCountiesInput
    upsert?: CityUpsertWithoutCountiesInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutCountiesInput, CityUncheckedUpdateWithoutCountiesInput>
  }

  export type StateCreateNestedOneWithoutCitiesInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    connect?: StateWhereUniqueInput
  }

  export type CountyCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<CountyCreateWithoutCityInput>, Enumerable<CountyUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<CountyCreateOrConnectWithoutCityInput>
    createMany?: CountyCreateManyCityInputEnvelope
    connect?: Enumerable<CountyWhereUniqueInput>
  }

  export type CountyUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<CountyCreateWithoutCityInput>, Enumerable<CountyUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<CountyCreateOrConnectWithoutCityInput>
    createMany?: CountyCreateManyCityInputEnvelope
    connect?: Enumerable<CountyWhereUniqueInput>
  }

  export type StateUpdateOneRequiredWithoutCitiesInput = {
    create?: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: StateCreateOrConnectWithoutCitiesInput
    upsert?: StateUpsertWithoutCitiesInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
  }

  export type CountyUpdateManyWithoutCityInput = {
    create?: XOR<Enumerable<CountyCreateWithoutCityInput>, Enumerable<CountyUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<CountyCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<CountyUpsertWithWhereUniqueWithoutCityInput>
    createMany?: CountyCreateManyCityInputEnvelope
    connect?: Enumerable<CountyWhereUniqueInput>
    set?: Enumerable<CountyWhereUniqueInput>
    disconnect?: Enumerable<CountyWhereUniqueInput>
    delete?: Enumerable<CountyWhereUniqueInput>
    update?: Enumerable<CountyUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<CountyUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<CountyScalarWhereInput>
  }

  export type CountyUncheckedUpdateManyWithoutCityInput = {
    create?: XOR<Enumerable<CountyCreateWithoutCityInput>, Enumerable<CountyUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<CountyCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<CountyUpsertWithWhereUniqueWithoutCityInput>
    createMany?: CountyCreateManyCityInputEnvelope
    connect?: Enumerable<CountyWhereUniqueInput>
    set?: Enumerable<CountyWhereUniqueInput>
    disconnect?: Enumerable<CountyWhereUniqueInput>
    delete?: Enumerable<CountyWhereUniqueInput>
    update?: Enumerable<CountyUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<CountyUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<CountyScalarWhereInput>
  }

  export type CityCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type CountryCreateNestedOneWithoutStatesInput = {
    create?: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStatesInput
    connect?: CountryWhereUniqueInput
  }

  export type CityUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type CityUpdateManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type CountryUpdateOneRequiredWithoutStatesInput = {
    create?: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStatesInput
    upsert?: CountryUpsertWithoutStatesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutStatesInput, CountryUncheckedUpdateWithoutStatesInput>
  }

  export type CityUncheckedUpdateManyWithoutStateInput = {
    create?: XOR<Enumerable<CityCreateWithoutStateInput>, Enumerable<CityUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutStateInput>
    createMany?: CityCreateManyStateInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type CurrencyCreateNestedOneWithoutCountriesInput = {
    create?: XOR<CurrencyCreateWithoutCountriesInput, CurrencyUncheckedCreateWithoutCountriesInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutCountriesInput
    connect?: CurrencyWhereUniqueInput
  }

  export type StateCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type StateUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type CurrencyUpdateOneRequiredWithoutCountriesInput = {
    create?: XOR<CurrencyCreateWithoutCountriesInput, CurrencyUncheckedCreateWithoutCountriesInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutCountriesInput
    upsert?: CurrencyUpsertWithoutCountriesInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<CurrencyUpdateWithoutCountriesInput, CurrencyUncheckedUpdateWithoutCountriesInput>
  }

  export type StateUpdateManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type StateUncheckedUpdateManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type PaymentCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCurrencyInput>, Enumerable<PaymentUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCurrencyInput>
    createMany?: PaymentCreateManyCurrencyInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type CountryCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<CountryCreateWithoutCurrencyInput>, Enumerable<CountryUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<CountryCreateOrConnectWithoutCurrencyInput>
    createMany?: CountryCreateManyCurrencyInputEnvelope
    connect?: Enumerable<CountryWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCurrencyInput>, Enumerable<PaymentUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCurrencyInput>
    createMany?: PaymentCreateManyCurrencyInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type CountryUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<CountryCreateWithoutCurrencyInput>, Enumerable<CountryUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<CountryCreateOrConnectWithoutCurrencyInput>
    createMany?: CountryCreateManyCurrencyInputEnvelope
    connect?: Enumerable<CountryWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PaymentUpdateManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCurrencyInput>, Enumerable<PaymentUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutCurrencyInput>
    createMany?: PaymentCreateManyCurrencyInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type CountryUpdateManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<CountryCreateWithoutCurrencyInput>, Enumerable<CountryUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<CountryCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<CountryUpsertWithWhereUniqueWithoutCurrencyInput>
    createMany?: CountryCreateManyCurrencyInputEnvelope
    connect?: Enumerable<CountryWhereUniqueInput>
    set?: Enumerable<CountryWhereUniqueInput>
    disconnect?: Enumerable<CountryWhereUniqueInput>
    delete?: Enumerable<CountryWhereUniqueInput>
    update?: Enumerable<CountryUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<CountryUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<CountryScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCurrencyInput>, Enumerable<PaymentUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutCurrencyInput>
    createMany?: PaymentCreateManyCurrencyInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type CountryUncheckedUpdateManyWithoutCurrencyInput = {
    create?: XOR<Enumerable<CountryCreateWithoutCurrencyInput>, Enumerable<CountryUncheckedCreateWithoutCurrencyInput>>
    connectOrCreate?: Enumerable<CountryCreateOrConnectWithoutCurrencyInput>
    upsert?: Enumerable<CountryUpsertWithWhereUniqueWithoutCurrencyInput>
    createMany?: CountryCreateManyCurrencyInputEnvelope
    connect?: Enumerable<CountryWhereUniqueInput>
    set?: Enumerable<CountryWhereUniqueInput>
    disconnect?: Enumerable<CountryWhereUniqueInput>
    delete?: Enumerable<CountryWhereUniqueInput>
    update?: Enumerable<CountryUpdateWithWhereUniqueWithoutCurrencyInput>
    updateMany?: Enumerable<CountryUpdateManyWithWhereWithoutCurrencyInput>
    deleteMany?: Enumerable<CountryScalarWhereInput>
  }

  export type CurrencyCreateNestedOneWithoutPaymentInput = {
    create?: XOR<CurrencyCreateWithoutPaymentInput, CurrencyUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutPaymentInput
    connect?: CurrencyWhereUniqueInput
  }

  export type CurrencyUpdateOneRequiredWithoutPaymentInput = {
    create?: XOR<CurrencyCreateWithoutPaymentInput, CurrencyUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutPaymentInput
    upsert?: CurrencyUpsertWithoutPaymentInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<CurrencyUpdateWithoutPaymentInput, CurrencyUncheckedUpdateWithoutPaymentInput>
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutParentInput>, Enumerable<CategoryUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutParentInput>
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<PostCreateWithoutCategoryInput>, Enumerable<PostUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutCategoryInput>
    createMany?: PostCreateManyCategoryInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PropertyCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<PropertyCreateWithoutCategoryInput>, Enumerable<PropertyUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<PropertyCreateOrConnectWithoutCategoryInput>
    createMany?: PropertyCreateManyCategoryInputEnvelope
    connect?: Enumerable<PropertyWhereUniqueInput>
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutParentInput>, Enumerable<CategoryUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutParentInput>
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<PostCreateWithoutCategoryInput>, Enumerable<PostUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutCategoryInput>
    createMany?: PostCreateManyCategoryInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PropertyUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<PropertyCreateWithoutCategoryInput>, Enumerable<PropertyUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<PropertyCreateOrConnectWithoutCategoryInput>
    createMany?: PropertyCreateManyCategoryInputEnvelope
    connect?: Enumerable<PropertyWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUpdateManyWithoutParentInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutParentInput>, Enumerable<CategoryUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutParentInput>
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type CategoryUpdateOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type PostUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<PostCreateWithoutCategoryInput>, Enumerable<PostUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: PostCreateManyCategoryInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type PropertyUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<PropertyCreateWithoutCategoryInput>, Enumerable<PropertyUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<PropertyCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<PropertyUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: PropertyCreateManyCategoryInputEnvelope
    connect?: Enumerable<PropertyWhereUniqueInput>
    set?: Enumerable<PropertyWhereUniqueInput>
    disconnect?: Enumerable<PropertyWhereUniqueInput>
    delete?: Enumerable<PropertyWhereUniqueInput>
    update?: Enumerable<PropertyUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<PropertyUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<PropertyScalarWhereInput>
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutParentInput>, Enumerable<CategoryUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutParentInput>
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<PostCreateWithoutCategoryInput>, Enumerable<PostUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: PostCreateManyCategoryInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type PropertyUncheckedUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<PropertyCreateWithoutCategoryInput>, Enumerable<PropertyUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<PropertyCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<PropertyUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: PropertyCreateManyCategoryInputEnvelope
    connect?: Enumerable<PropertyWhereUniqueInput>
    set?: Enumerable<PropertyWhereUniqueInput>
    disconnect?: Enumerable<PropertyWhereUniqueInput>
    delete?: Enumerable<PropertyWhereUniqueInput>
    update?: Enumerable<PropertyUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<PropertyUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<PropertyScalarWhereInput>
  }

  export type PossibleValuesCreateNestedManyWithoutPropertyInput = {
    create?: XOR<Enumerable<PossibleValuesCreateWithoutPropertyInput>, Enumerable<PossibleValuesUncheckedCreateWithoutPropertyInput>>
    connectOrCreate?: Enumerable<PossibleValuesCreateOrConnectWithoutPropertyInput>
    createMany?: PossibleValuesCreateManyPropertyInputEnvelope
    connect?: Enumerable<PossibleValuesWhereUniqueInput>
  }

  export type ScreenControlCreateNestedOneWithoutPropertyInput = {
    create?: XOR<ScreenControlCreateWithoutPropertyInput, ScreenControlUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: ScreenControlCreateOrConnectWithoutPropertyInput
    connect?: ScreenControlWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<CategoryCreateWithoutPropertiesInput, CategoryUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPropertiesInput
    connect?: CategoryWhereUniqueInput
  }

  export type PossibleValuesUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<Enumerable<PossibleValuesCreateWithoutPropertyInput>, Enumerable<PossibleValuesUncheckedCreateWithoutPropertyInput>>
    connectOrCreate?: Enumerable<PossibleValuesCreateOrConnectWithoutPropertyInput>
    createMany?: PossibleValuesCreateManyPropertyInputEnvelope
    connect?: Enumerable<PossibleValuesWhereUniqueInput>
  }

  export type PossibleValuesUpdateManyWithoutPropertyInput = {
    create?: XOR<Enumerable<PossibleValuesCreateWithoutPropertyInput>, Enumerable<PossibleValuesUncheckedCreateWithoutPropertyInput>>
    connectOrCreate?: Enumerable<PossibleValuesCreateOrConnectWithoutPropertyInput>
    upsert?: Enumerable<PossibleValuesUpsertWithWhereUniqueWithoutPropertyInput>
    createMany?: PossibleValuesCreateManyPropertyInputEnvelope
    connect?: Enumerable<PossibleValuesWhereUniqueInput>
    set?: Enumerable<PossibleValuesWhereUniqueInput>
    disconnect?: Enumerable<PossibleValuesWhereUniqueInput>
    delete?: Enumerable<PossibleValuesWhereUniqueInput>
    update?: Enumerable<PossibleValuesUpdateWithWhereUniqueWithoutPropertyInput>
    updateMany?: Enumerable<PossibleValuesUpdateManyWithWhereWithoutPropertyInput>
    deleteMany?: Enumerable<PossibleValuesScalarWhereInput>
  }

  export type ScreenControlUpdateOneRequiredWithoutPropertyInput = {
    create?: XOR<ScreenControlCreateWithoutPropertyInput, ScreenControlUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: ScreenControlCreateOrConnectWithoutPropertyInput
    upsert?: ScreenControlUpsertWithoutPropertyInput
    connect?: ScreenControlWhereUniqueInput
    update?: XOR<ScreenControlUpdateWithoutPropertyInput, ScreenControlUncheckedUpdateWithoutPropertyInput>
  }

  export type CategoryUpdateOneWithoutPropertiesInput = {
    create?: XOR<CategoryCreateWithoutPropertiesInput, CategoryUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPropertiesInput
    upsert?: CategoryUpsertWithoutPropertiesInput
    connect?: CategoryWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CategoryUpdateWithoutPropertiesInput, CategoryUncheckedUpdateWithoutPropertiesInput>
  }

  export type PossibleValuesUncheckedUpdateManyWithoutPropertyInput = {
    create?: XOR<Enumerable<PossibleValuesCreateWithoutPropertyInput>, Enumerable<PossibleValuesUncheckedCreateWithoutPropertyInput>>
    connectOrCreate?: Enumerable<PossibleValuesCreateOrConnectWithoutPropertyInput>
    upsert?: Enumerable<PossibleValuesUpsertWithWhereUniqueWithoutPropertyInput>
    createMany?: PossibleValuesCreateManyPropertyInputEnvelope
    connect?: Enumerable<PossibleValuesWhereUniqueInput>
    set?: Enumerable<PossibleValuesWhereUniqueInput>
    disconnect?: Enumerable<PossibleValuesWhereUniqueInput>
    delete?: Enumerable<PossibleValuesWhereUniqueInput>
    update?: Enumerable<PossibleValuesUpdateWithWhereUniqueWithoutPropertyInput>
    updateMany?: Enumerable<PossibleValuesUpdateManyWithWhereWithoutPropertyInput>
    deleteMany?: Enumerable<PossibleValuesScalarWhereInput>
  }

  export type PropertyCreateNestedOneWithoutValuesInput = {
    create?: XOR<PropertyCreateWithoutValuesInput, PropertyUncheckedCreateWithoutValuesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutValuesInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutValuesInput = {
    create?: XOR<PropertyCreateWithoutValuesInput, PropertyUncheckedCreateWithoutValuesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutValuesInput
    upsert?: PropertyUpsertWithoutValuesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<PropertyUpdateWithoutValuesInput, PropertyUncheckedUpdateWithoutValuesInput>
  }

  export type PropertyCreateNestedManyWithoutScreenControlInput = {
    create?: XOR<Enumerable<PropertyCreateWithoutScreenControlInput>, Enumerable<PropertyUncheckedCreateWithoutScreenControlInput>>
    connectOrCreate?: Enumerable<PropertyCreateOrConnectWithoutScreenControlInput>
    createMany?: PropertyCreateManyScreenControlInputEnvelope
    connect?: Enumerable<PropertyWhereUniqueInput>
  }

  export type PropertyUncheckedCreateNestedManyWithoutScreenControlInput = {
    create?: XOR<Enumerable<PropertyCreateWithoutScreenControlInput>, Enumerable<PropertyUncheckedCreateWithoutScreenControlInput>>
    connectOrCreate?: Enumerable<PropertyCreateOrConnectWithoutScreenControlInput>
    createMany?: PropertyCreateManyScreenControlInputEnvelope
    connect?: Enumerable<PropertyWhereUniqueInput>
  }

  export type PropertyUpdateManyWithoutScreenControlInput = {
    create?: XOR<Enumerable<PropertyCreateWithoutScreenControlInput>, Enumerable<PropertyUncheckedCreateWithoutScreenControlInput>>
    connectOrCreate?: Enumerable<PropertyCreateOrConnectWithoutScreenControlInput>
    upsert?: Enumerable<PropertyUpsertWithWhereUniqueWithoutScreenControlInput>
    createMany?: PropertyCreateManyScreenControlInputEnvelope
    connect?: Enumerable<PropertyWhereUniqueInput>
    set?: Enumerable<PropertyWhereUniqueInput>
    disconnect?: Enumerable<PropertyWhereUniqueInput>
    delete?: Enumerable<PropertyWhereUniqueInput>
    update?: Enumerable<PropertyUpdateWithWhereUniqueWithoutScreenControlInput>
    updateMany?: Enumerable<PropertyUpdateManyWithWhereWithoutScreenControlInput>
    deleteMany?: Enumerable<PropertyScalarWhereInput>
  }

  export type PropertyUncheckedUpdateManyWithoutScreenControlInput = {
    create?: XOR<Enumerable<PropertyCreateWithoutScreenControlInput>, Enumerable<PropertyUncheckedCreateWithoutScreenControlInput>>
    connectOrCreate?: Enumerable<PropertyCreateOrConnectWithoutScreenControlInput>
    upsert?: Enumerable<PropertyUpsertWithWhereUniqueWithoutScreenControlInput>
    createMany?: PropertyCreateManyScreenControlInputEnvelope
    connect?: Enumerable<PropertyWhereUniqueInput>
    set?: Enumerable<PropertyWhereUniqueInput>
    disconnect?: Enumerable<PropertyWhereUniqueInput>
    delete?: Enumerable<PropertyWhereUniqueInput>
    update?: Enumerable<PropertyUpdateWithWhereUniqueWithoutScreenControlInput>
    updateMany?: Enumerable<PropertyUpdateManyWithWhereWithoutScreenControlInput>
    deleteMany?: Enumerable<PropertyScalarWhereInput>
  }

  export type CategoryCreateNestedOneWithoutPostsInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput
    connect?: CategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ImageCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<ImageCreateWithoutPostInput>, Enumerable<ImageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutPostInput>
    createMany?: ImageCreateManyPostInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
  }

  export type ImageUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<ImageCreateWithoutPostInput>, Enumerable<ImageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutPostInput>
    createMany?: ImageCreateManyPostInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUpdateOneRequiredWithoutPostsInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput
    upsert?: CategoryUpsertWithoutPostsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateOneRequiredWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type ImageUpdateManyWithoutPostInput = {
    create?: XOR<Enumerable<ImageCreateWithoutPostInput>, Enumerable<ImageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutPostInput>
    createMany?: ImageCreateManyPostInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
  }

  export type ImageUncheckedUpdateManyWithoutPostInput = {
    create?: XOR<Enumerable<ImageCreateWithoutPostInput>, Enumerable<ImageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutPostInput>
    createMany?: ImageCreateManyPostInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
  }

  export type PostCreateNestedOneWithoutImagesInput = {
    create?: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PostCreateOrConnectWithoutImagesInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutImagesInput = {
    create?: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PostCreateOrConnectWithoutImagesInput
    upsert?: PostUpsertWithoutImagesInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutImagesInput, PostUncheckedUpdateWithoutImagesInput>
  }

  export type AttributeValuesCreateNestedManyWithoutAttributeInput = {
    create?: XOR<Enumerable<AttributeValuesCreateWithoutAttributeInput>, Enumerable<AttributeValuesUncheckedCreateWithoutAttributeInput>>
    connectOrCreate?: Enumerable<AttributeValuesCreateOrConnectWithoutAttributeInput>
    createMany?: AttributeValuesCreateManyAttributeInputEnvelope
    connect?: Enumerable<AttributeValuesWhereUniqueInput>
  }

  export type AttributeValuesUncheckedCreateNestedManyWithoutAttributeInput = {
    create?: XOR<Enumerable<AttributeValuesCreateWithoutAttributeInput>, Enumerable<AttributeValuesUncheckedCreateWithoutAttributeInput>>
    connectOrCreate?: Enumerable<AttributeValuesCreateOrConnectWithoutAttributeInput>
    createMany?: AttributeValuesCreateManyAttributeInputEnvelope
    connect?: Enumerable<AttributeValuesWhereUniqueInput>
  }

  export type AttributeValuesUpdateManyWithoutAttributeInput = {
    create?: XOR<Enumerable<AttributeValuesCreateWithoutAttributeInput>, Enumerable<AttributeValuesUncheckedCreateWithoutAttributeInput>>
    connectOrCreate?: Enumerable<AttributeValuesCreateOrConnectWithoutAttributeInput>
    upsert?: Enumerable<AttributeValuesUpsertWithWhereUniqueWithoutAttributeInput>
    createMany?: AttributeValuesCreateManyAttributeInputEnvelope
    connect?: Enumerable<AttributeValuesWhereUniqueInput>
    set?: Enumerable<AttributeValuesWhereUniqueInput>
    disconnect?: Enumerable<AttributeValuesWhereUniqueInput>
    delete?: Enumerable<AttributeValuesWhereUniqueInput>
    update?: Enumerable<AttributeValuesUpdateWithWhereUniqueWithoutAttributeInput>
    updateMany?: Enumerable<AttributeValuesUpdateManyWithWhereWithoutAttributeInput>
    deleteMany?: Enumerable<AttributeValuesScalarWhereInput>
  }

  export type AttributeValuesUncheckedUpdateManyWithoutAttributeInput = {
    create?: XOR<Enumerable<AttributeValuesCreateWithoutAttributeInput>, Enumerable<AttributeValuesUncheckedCreateWithoutAttributeInput>>
    connectOrCreate?: Enumerable<AttributeValuesCreateOrConnectWithoutAttributeInput>
    upsert?: Enumerable<AttributeValuesUpsertWithWhereUniqueWithoutAttributeInput>
    createMany?: AttributeValuesCreateManyAttributeInputEnvelope
    connect?: Enumerable<AttributeValuesWhereUniqueInput>
    set?: Enumerable<AttributeValuesWhereUniqueInput>
    disconnect?: Enumerable<AttributeValuesWhereUniqueInput>
    delete?: Enumerable<AttributeValuesWhereUniqueInput>
    update?: Enumerable<AttributeValuesUpdateWithWhereUniqueWithoutAttributeInput>
    updateMany?: Enumerable<AttributeValuesUpdateManyWithWhereWithoutAttributeInput>
    deleteMany?: Enumerable<AttributeValuesScalarWhereInput>
  }

  export type AttributeCreateNestedOneWithoutValuesInput = {
    create?: XOR<AttributeCreateWithoutValuesInput, AttributeUncheckedCreateWithoutValuesInput>
    connectOrCreate?: AttributeCreateOrConnectWithoutValuesInput
    connect?: AttributeWhereUniqueInput
  }

  export type AttributeUpdateOneRequiredWithoutValuesInput = {
    create?: XOR<AttributeCreateWithoutValuesInput, AttributeUncheckedCreateWithoutValuesInput>
    connectOrCreate?: AttributeCreateOrConnectWithoutValuesInput
    upsert?: AttributeUpsertWithoutValuesInput
    connect?: AttributeWhereUniqueInput
    update?: XOR<AttributeUpdateWithoutValuesInput, AttributeUncheckedUpdateWithoutValuesInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    count?: NestedIntFilter
    min?: NestedBoolFilter
    max?: NestedBoolFilter
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    count?: NestedIntFilter
    min?: NestedEnumRoleFilter
    max?: NestedEnumRoleFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedFloatFilter
    min?: NestedFloatFilter
    max?: NestedFloatFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedIntNullableFilter
    min?: NestedIntNullableFilter
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedFloatNullableFilter
    min?: NestedFloatNullableFilter
    max?: NestedFloatNullableFilter
  }

  export type LanguageCreateWithoutUserInput = {
    name: string
  }

  export type LanguageUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
  }

  export type LanguageCreateOrConnectWithoutUserInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutUserInput, LanguageUncheckedCreateWithoutUserInput>
  }

  export type PostCreateWithoutUserInput = {
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
    category: CategoryCreateNestedOneWithoutPostsInput
    images?: ImageCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: number
    categoryId: number
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: Enumerable<PostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LanguageUpsertWithoutUserInput = {
    update: XOR<LanguageUpdateWithoutUserInput, LanguageUncheckedUpdateWithoutUserInput>
    create: XOR<LanguageCreateWithoutUserInput, LanguageUncheckedCreateWithoutUserInput>
  }

  export type LanguageUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostScalarWhereInput = {
    AND?: Enumerable<PostScalarWhereInput>
    OR?: Enumerable<PostScalarWhereInput>
    NOT?: Enumerable<PostScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    categoryId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    lastRenewedAt?: DateTimeFilter | Date | string
    title?: StringFilter | string
    detail?: StringFilter | string
    isActive?: BoolFilter | boolean
    isSeller?: BoolFilter | boolean
    isIndividual?: BoolFilter | boolean
    expectedPrice?: FloatNullableFilter | number | null
    isPriceNegotiable?: BoolFilter | boolean
  }

  export type UserCreateWithoutLanguageInput = {
    email: string
    firstName: string
    lastName: string
    password: string
    phone: string
    countyId: number
    zip: string
    isPrivacyEneable?: boolean
    role?: Role
    posts?: PostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLanguageInput = {
    id?: number
    email: string
    firstName: string
    lastName: string
    password: string
    phone: string
    countyId: number
    zip: string
    isPrivacyEneable?: boolean
    role?: Role
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLanguageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLanguageInput, UserUncheckedCreateWithoutLanguageInput>
  }

  export type UserCreateManyLanguageInputEnvelope = {
    data: Enumerable<UserCreateManyLanguageInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutLanguageInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLanguageInput, UserUncheckedUpdateWithoutLanguageInput>
    create: XOR<UserCreateWithoutLanguageInput, UserUncheckedCreateWithoutLanguageInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLanguageInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLanguageInput, UserUncheckedUpdateWithoutLanguageInput>
  }

  export type UserUpdateManyWithWhereWithoutLanguageInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    password?: StringFilter | string
    phone?: StringFilter | string
    countyId?: IntFilter | number
    zip?: StringFilter | string
    isPrivacyEneable?: BoolFilter | boolean
    role?: EnumRoleFilter | Role
    languageId?: IntFilter | number
  }

  export type CityCreateWithoutCountiesInput = {
    name: string
    state: StateCreateNestedOneWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutCountiesInput = {
    id?: number
    stateId: number
    name: string
  }

  export type CityCreateOrConnectWithoutCountiesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountiesInput, CityUncheckedCreateWithoutCountiesInput>
  }

  export type CityUpsertWithoutCountiesInput = {
    update: XOR<CityUpdateWithoutCountiesInput, CityUncheckedUpdateWithoutCountiesInput>
    create: XOR<CityCreateWithoutCountiesInput, CityUncheckedCreateWithoutCountiesInput>
  }

  export type CityUpdateWithoutCountiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StateUpdateOneRequiredWithoutCitiesInput
  }

  export type CityUncheckedUpdateWithoutCountiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    stateId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StateCreateWithoutCitiesInput = {
    name: string
    country: CountryCreateNestedOneWithoutStatesInput
  }

  export type StateUncheckedCreateWithoutCitiesInput = {
    id?: number
    countryId: number
    name: string
  }

  export type StateCreateOrConnectWithoutCitiesInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
  }

  export type CountyCreateWithoutCityInput = {
    name: string
  }

  export type CountyUncheckedCreateWithoutCityInput = {
    id?: number
    name: string
  }

  export type CountyCreateOrConnectWithoutCityInput = {
    where: CountyWhereUniqueInput
    create: XOR<CountyCreateWithoutCityInput, CountyUncheckedCreateWithoutCityInput>
  }

  export type CountyCreateManyCityInputEnvelope = {
    data: Enumerable<CountyCreateManyCityInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithoutCitiesInput = {
    update: XOR<StateUpdateWithoutCitiesInput, StateUncheckedUpdateWithoutCitiesInput>
    create: XOR<StateCreateWithoutCitiesInput, StateUncheckedCreateWithoutCitiesInput>
  }

  export type StateUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutStatesInput
  }

  export type StateUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountyUpsertWithWhereUniqueWithoutCityInput = {
    where: CountyWhereUniqueInput
    update: XOR<CountyUpdateWithoutCityInput, CountyUncheckedUpdateWithoutCityInput>
    create: XOR<CountyCreateWithoutCityInput, CountyUncheckedCreateWithoutCityInput>
  }

  export type CountyUpdateWithWhereUniqueWithoutCityInput = {
    where: CountyWhereUniqueInput
    data: XOR<CountyUpdateWithoutCityInput, CountyUncheckedUpdateWithoutCityInput>
  }

  export type CountyUpdateManyWithWhereWithoutCityInput = {
    where: CountyScalarWhereInput
    data: XOR<CountyUpdateManyMutationInput, CountyUncheckedUpdateManyWithoutCountiesInput>
  }

  export type CountyScalarWhereInput = {
    AND?: Enumerable<CountyScalarWhereInput>
    OR?: Enumerable<CountyScalarWhereInput>
    NOT?: Enumerable<CountyScalarWhereInput>
    id?: IntFilter | number
    cityId?: IntFilter | number
    name?: StringFilter | string
  }

  export type CityCreateWithoutStateInput = {
    name: string
    counties?: CountyCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutStateInput = {
    id?: number
    name: string
    counties?: CountyUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutStateInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityCreateManyStateInputEnvelope = {
    data: Enumerable<CityCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type CountryCreateWithoutStatesInput = {
    name: string
    currency: CurrencyCreateNestedOneWithoutCountriesInput
  }

  export type CountryUncheckedCreateWithoutStatesInput = {
    id?: number
    currencyId: number
    name: string
  }

  export type CountryCreateOrConnectWithoutStatesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
  }

  export type CityUpsertWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
    create: XOR<CityCreateWithoutStateInput, CityUncheckedCreateWithoutStateInput>
  }

  export type CityUpdateWithWhereUniqueWithoutStateInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutStateInput, CityUncheckedUpdateWithoutStateInput>
  }

  export type CityUpdateManyWithWhereWithoutStateInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCitiesInput>
  }

  export type CityScalarWhereInput = {
    AND?: Enumerable<CityScalarWhereInput>
    OR?: Enumerable<CityScalarWhereInput>
    NOT?: Enumerable<CityScalarWhereInput>
    id?: IntFilter | number
    stateId?: IntFilter | number
    name?: StringFilter | string
  }

  export type CountryUpsertWithoutStatesInput = {
    update: XOR<CountryUpdateWithoutStatesInput, CountryUncheckedUpdateWithoutStatesInput>
    create: XOR<CountryCreateWithoutStatesInput, CountryUncheckedCreateWithoutStatesInput>
  }

  export type CountryUpdateWithoutStatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    currency?: CurrencyUpdateOneRequiredWithoutCountriesInput
  }

  export type CountryUncheckedUpdateWithoutStatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    currencyId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CurrencyCreateWithoutCountriesInput = {
    code: string
    exchangeRate: number
    Payment?: PaymentCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutCountriesInput = {
    id?: number
    code: string
    exchangeRate: number
    Payment?: PaymentUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutCountriesInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutCountriesInput, CurrencyUncheckedCreateWithoutCountriesInput>
  }

  export type StateCreateWithoutCountryInput = {
    name: string
    cities?: CityCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    cities?: CityUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutCountryInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateCreateManyCountryInputEnvelope = {
    data: Enumerable<StateCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type CurrencyUpsertWithoutCountriesInput = {
    update: XOR<CurrencyUpdateWithoutCountriesInput, CurrencyUncheckedUpdateWithoutCountriesInput>
    create: XOR<CurrencyCreateWithoutCountriesInput, CurrencyUncheckedCreateWithoutCountriesInput>
  }

  export type CurrencyUpdateWithoutCountriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    Payment?: PaymentUpdateManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedUpdateWithoutCountriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    Payment?: PaymentUncheckedUpdateManyWithoutCurrencyInput
  }

  export type StateUpsertWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    update: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateUpdateWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    data: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
  }

  export type StateUpdateManyWithWhereWithoutCountryInput = {
    where: StateScalarWhereInput
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyWithoutStatesInput>
  }

  export type StateScalarWhereInput = {
    AND?: Enumerable<StateScalarWhereInput>
    OR?: Enumerable<StateScalarWhereInput>
    NOT?: Enumerable<StateScalarWhereInput>
    id?: IntFilter | number
    countryId?: IntFilter | number
    name?: StringFilter | string
  }

  export type PaymentCreateWithoutCurrencyInput = {
    method: string
    status: string
  }

  export type PaymentUncheckedCreateWithoutCurrencyInput = {
    id?: number
    method: string
    status: string
  }

  export type PaymentCreateOrConnectWithoutCurrencyInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCurrencyInput, PaymentUncheckedCreateWithoutCurrencyInput>
  }

  export type PaymentCreateManyCurrencyInputEnvelope = {
    data: Enumerable<PaymentCreateManyCurrencyInput>
    skipDuplicates?: boolean
  }

  export type CountryCreateWithoutCurrencyInput = {
    name: string
    states?: StateCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutCurrencyInput = {
    id?: number
    name: string
    states?: StateUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutCurrencyInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCurrencyInput, CountryUncheckedCreateWithoutCurrencyInput>
  }

  export type CountryCreateManyCurrencyInputEnvelope = {
    data: Enumerable<CountryCreateManyCurrencyInput>
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCurrencyInput, PaymentUncheckedUpdateWithoutCurrencyInput>
    create: XOR<PaymentCreateWithoutCurrencyInput, PaymentUncheckedCreateWithoutCurrencyInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCurrencyInput, PaymentUncheckedUpdateWithoutCurrencyInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCurrencyInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: Enumerable<PaymentScalarWhereInput>
    OR?: Enumerable<PaymentScalarWhereInput>
    NOT?: Enumerable<PaymentScalarWhereInput>
    id?: IntFilter | number
    currencyId?: IntFilter | number
    method?: StringFilter | string
    status?: StringFilter | string
  }

  export type CountryUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: CountryWhereUniqueInput
    update: XOR<CountryUpdateWithoutCurrencyInput, CountryUncheckedUpdateWithoutCurrencyInput>
    create: XOR<CountryCreateWithoutCurrencyInput, CountryUncheckedCreateWithoutCurrencyInput>
  }

  export type CountryUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: CountryWhereUniqueInput
    data: XOR<CountryUpdateWithoutCurrencyInput, CountryUncheckedUpdateWithoutCurrencyInput>
  }

  export type CountryUpdateManyWithWhereWithoutCurrencyInput = {
    where: CountryScalarWhereInput
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyWithoutCountriesInput>
  }

  export type CountryScalarWhereInput = {
    AND?: Enumerable<CountryScalarWhereInput>
    OR?: Enumerable<CountryScalarWhereInput>
    NOT?: Enumerable<CountryScalarWhereInput>
    id?: IntFilter | number
    currencyId?: IntFilter | number
    name?: StringFilter | string
  }

  export type CurrencyCreateWithoutPaymentInput = {
    code: string
    exchangeRate: number
    countries?: CountryCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutPaymentInput = {
    id?: number
    code: string
    exchangeRate: number
    countries?: CountryUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutPaymentInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutPaymentInput, CurrencyUncheckedCreateWithoutPaymentInput>
  }

  export type CurrencyUpsertWithoutPaymentInput = {
    update: XOR<CurrencyUpdateWithoutPaymentInput, CurrencyUncheckedUpdateWithoutPaymentInput>
    create: XOR<CurrencyCreateWithoutPaymentInput, CurrencyUncheckedCreateWithoutPaymentInput>
  }

  export type CurrencyUpdateWithoutPaymentInput = {
    code?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    countries?: CountryUpdateManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    countries?: CountryUncheckedUpdateManyWithoutCurrencyInput
  }

  export type CategoryCreateWithoutParentInput = {
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
    children?: CategoryCreateNestedManyWithoutParentInput
    posts?: PostCreateNestedManyWithoutCategoryInput
    properties?: PropertyCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    posts?: PostUncheckedCreateNestedManyWithoutCategoryInput
    properties?: PropertyUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: Enumerable<CategoryCreateManyParentInput>
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutChildrenInput = {
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    posts?: PostCreateNestedManyWithoutCategoryInput
    properties?: PropertyCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: number
    parentId?: number | null
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
    posts?: PostUncheckedCreateNestedManyWithoutCategoryInput
    properties?: PropertyUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type PostCreateWithoutCategoryInput = {
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
    user: UserCreateNestedOneWithoutPostsInput
    images?: ImageCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCategoryInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
    images?: ImageUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCategoryInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCategoryInput, PostUncheckedCreateWithoutCategoryInput>
  }

  export type PostCreateManyCategoryInputEnvelope = {
    data: Enumerable<PostCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutCategoryInput = {
    name: string
    unit: string
    isMandatory: boolean
    values?: PossibleValuesCreateNestedManyWithoutPropertyInput
    screenControl: ScreenControlCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    unit: string
    isMandatory: boolean
    screenControlId: number
    values?: PossibleValuesUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutCategoryInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput>
  }

  export type PropertyCreateManyCategoryInputEnvelope = {
    data: Enumerable<PropertyCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutChildrenInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: Enumerable<CategoryScalarWhereInput>
    OR?: Enumerable<CategoryScalarWhereInput>
    NOT?: Enumerable<CategoryScalarWhereInput>
    id?: IntFilter | number
    parentId?: IntNullableFilter | number | null
    name?: StringFilter | string
    maxImgs?: IntFilter | number
    postValidityIntervalInDays?: IntNullableFilter | number | null
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
    parent?: CategoryUpdateOneWithoutChildrenInput
    posts?: PostUpdateManyWithoutCategoryInput
    properties?: PropertyUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUncheckedUpdateManyWithoutCategoryInput
    properties?: PropertyUncheckedUpdateManyWithoutCategoryInput
  }

  export type PostUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutCategoryInput, PostUncheckedUpdateWithoutCategoryInput>
    create: XOR<PostCreateWithoutCategoryInput, PostUncheckedCreateWithoutCategoryInput>
  }

  export type PostUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutCategoryInput, PostUncheckedUpdateWithoutCategoryInput>
  }

  export type PostUpdateManyWithWhereWithoutCategoryInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostsInput>
  }

  export type PropertyUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutCategoryInput, PropertyUncheckedUpdateWithoutCategoryInput>
    create: XOR<PropertyCreateWithoutCategoryInput, PropertyUncheckedCreateWithoutCategoryInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutCategoryInput, PropertyUncheckedUpdateWithoutCategoryInput>
  }

  export type PropertyUpdateManyWithWhereWithoutCategoryInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutPropertiesInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: Enumerable<PropertyScalarWhereInput>
    OR?: Enumerable<PropertyScalarWhereInput>
    NOT?: Enumerable<PropertyScalarWhereInput>
    id?: IntFilter | number
    categoryId?: IntFilter | number
    name?: StringFilter | string
    unit?: StringFilter | string
    isMandatory?: BoolFilter | boolean
    screenControlId?: IntFilter | number
  }

  export type PossibleValuesCreateWithoutPropertyInput = {
    value: number
  }

  export type PossibleValuesUncheckedCreateWithoutPropertyInput = {
    id?: number
    value: number
  }

  export type PossibleValuesCreateOrConnectWithoutPropertyInput = {
    where: PossibleValuesWhereUniqueInput
    create: XOR<PossibleValuesCreateWithoutPropertyInput, PossibleValuesUncheckedCreateWithoutPropertyInput>
  }

  export type PossibleValuesCreateManyPropertyInputEnvelope = {
    data: Enumerable<PossibleValuesCreateManyPropertyInput>
    skipDuplicates?: boolean
  }

  export type ScreenControlCreateWithoutPropertyInput = {
    screenControl: string
  }

  export type ScreenControlUncheckedCreateWithoutPropertyInput = {
    id?: number
    screenControl: string
  }

  export type ScreenControlCreateOrConnectWithoutPropertyInput = {
    where: ScreenControlWhereUniqueInput
    create: XOR<ScreenControlCreateWithoutPropertyInput, ScreenControlUncheckedCreateWithoutPropertyInput>
  }

  export type CategoryCreateWithoutPropertiesInput = {
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
    children?: CategoryCreateNestedManyWithoutParentInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    posts?: PostCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutPropertiesInput = {
    id?: number
    parentId?: number | null
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    posts?: PostUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutPropertiesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPropertiesInput, CategoryUncheckedCreateWithoutPropertiesInput>
  }

  export type PossibleValuesUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PossibleValuesWhereUniqueInput
    update: XOR<PossibleValuesUpdateWithoutPropertyInput, PossibleValuesUncheckedUpdateWithoutPropertyInput>
    create: XOR<PossibleValuesCreateWithoutPropertyInput, PossibleValuesUncheckedCreateWithoutPropertyInput>
  }

  export type PossibleValuesUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PossibleValuesWhereUniqueInput
    data: XOR<PossibleValuesUpdateWithoutPropertyInput, PossibleValuesUncheckedUpdateWithoutPropertyInput>
  }

  export type PossibleValuesUpdateManyWithWhereWithoutPropertyInput = {
    where: PossibleValuesScalarWhereInput
    data: XOR<PossibleValuesUpdateManyMutationInput, PossibleValuesUncheckedUpdateManyWithoutValuesInput>
  }

  export type PossibleValuesScalarWhereInput = {
    AND?: Enumerable<PossibleValuesScalarWhereInput>
    OR?: Enumerable<PossibleValuesScalarWhereInput>
    NOT?: Enumerable<PossibleValuesScalarWhereInput>
    id?: IntFilter | number
    propertyId?: IntFilter | number
    value?: IntFilter | number
  }

  export type ScreenControlUpsertWithoutPropertyInput = {
    update: XOR<ScreenControlUpdateWithoutPropertyInput, ScreenControlUncheckedUpdateWithoutPropertyInput>
    create: XOR<ScreenControlCreateWithoutPropertyInput, ScreenControlUncheckedCreateWithoutPropertyInput>
  }

  export type ScreenControlUpdateWithoutPropertyInput = {
    screenControl?: StringFieldUpdateOperationsInput | string
  }

  export type ScreenControlUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    screenControl?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUpsertWithoutPropertiesInput = {
    update: XOR<CategoryUpdateWithoutPropertiesInput, CategoryUncheckedUpdateWithoutPropertiesInput>
    create: XOR<CategoryCreateWithoutPropertiesInput, CategoryUncheckedCreateWithoutPropertiesInput>
  }

  export type CategoryUpdateWithoutPropertiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
    children?: CategoryUpdateManyWithoutParentInput
    parent?: CategoryUpdateOneWithoutChildrenInput
    posts?: PostUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
    posts?: PostUncheckedUpdateManyWithoutCategoryInput
  }

  export type PropertyCreateWithoutValuesInput = {
    name: string
    unit: string
    isMandatory: boolean
    screenControl: ScreenControlCreateNestedOneWithoutPropertyInput
    Category?: CategoryCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutValuesInput = {
    id?: number
    categoryId: number
    name: string
    unit: string
    isMandatory: boolean
    screenControlId: number
  }

  export type PropertyCreateOrConnectWithoutValuesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutValuesInput, PropertyUncheckedCreateWithoutValuesInput>
  }

  export type PropertyUpsertWithoutValuesInput = {
    update: XOR<PropertyUpdateWithoutValuesInput, PropertyUncheckedUpdateWithoutValuesInput>
    create: XOR<PropertyCreateWithoutValuesInput, PropertyUncheckedCreateWithoutValuesInput>
  }

  export type PropertyUpdateWithoutValuesInput = {
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    screenControl?: ScreenControlUpdateOneRequiredWithoutPropertyInput
    Category?: CategoryUpdateOneWithoutPropertiesInput
  }

  export type PropertyUncheckedUpdateWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    screenControlId?: IntFieldUpdateOperationsInput | number
  }

  export type PropertyCreateWithoutScreenControlInput = {
    name: string
    unit: string
    isMandatory: boolean
    values?: PossibleValuesCreateNestedManyWithoutPropertyInput
    Category?: CategoryCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutScreenControlInput = {
    id?: number
    categoryId: number
    name: string
    unit: string
    isMandatory: boolean
    values?: PossibleValuesUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutScreenControlInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutScreenControlInput, PropertyUncheckedCreateWithoutScreenControlInput>
  }

  export type PropertyCreateManyScreenControlInputEnvelope = {
    data: Enumerable<PropertyCreateManyScreenControlInput>
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithWhereUniqueWithoutScreenControlInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutScreenControlInput, PropertyUncheckedUpdateWithoutScreenControlInput>
    create: XOR<PropertyCreateWithoutScreenControlInput, PropertyUncheckedCreateWithoutScreenControlInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutScreenControlInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutScreenControlInput, PropertyUncheckedUpdateWithoutScreenControlInput>
  }

  export type PropertyUpdateManyWithWhereWithoutScreenControlInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutPropertyInput>
  }

  export type CategoryCreateWithoutPostsInput = {
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
    children?: CategoryCreateNestedManyWithoutParentInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    properties?: PropertyCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutPostsInput = {
    id?: number
    parentId?: number | null
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    properties?: PropertyUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutPostsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
  }

  export type UserCreateWithoutPostsInput = {
    email: string
    firstName: string
    lastName: string
    password: string
    phone: string
    countyId: number
    zip: string
    isPrivacyEneable?: boolean
    role?: Role
    language: LanguageCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: number
    email: string
    firstName: string
    lastName: string
    password: string
    phone: string
    countyId: number
    zip: string
    isPrivacyEneable?: boolean
    role?: Role
    languageId: number
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type ImageCreateWithoutPostInput = {
    name: string
    url: string
  }

  export type ImageUncheckedCreateWithoutPostInput = {
    id?: number
    name: string
    url: string
  }

  export type ImageCreateOrConnectWithoutPostInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutPostInput, ImageUncheckedCreateWithoutPostInput>
  }

  export type ImageCreateManyPostInputEnvelope = {
    data: Enumerable<ImageCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutPostsInput = {
    update: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
  }

  export type CategoryUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
    children?: CategoryUpdateManyWithoutParentInput
    parent?: CategoryUpdateOneWithoutChildrenInput
    properties?: PropertyUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
    properties?: PropertyUncheckedUpdateManyWithoutCategoryInput
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countyId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
    isPrivacyEneable?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | Role
    language?: LanguageUpdateOneRequiredWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countyId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
    isPrivacyEneable?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | Role
    languageId?: IntFieldUpdateOperationsInput | number
  }

  export type ImageUpsertWithWhereUniqueWithoutPostInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutPostInput, ImageUncheckedUpdateWithoutPostInput>
    create: XOR<ImageCreateWithoutPostInput, ImageUncheckedCreateWithoutPostInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutPostInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutPostInput, ImageUncheckedUpdateWithoutPostInput>
  }

  export type ImageUpdateManyWithWhereWithoutPostInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutImagesInput>
  }

  export type ImageScalarWhereInput = {
    AND?: Enumerable<ImageScalarWhereInput>
    OR?: Enumerable<ImageScalarWhereInput>
    NOT?: Enumerable<ImageScalarWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    name?: StringFilter | string
    url?: StringFilter | string
  }

  export type PostCreateWithoutImagesInput = {
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
    category: CategoryCreateNestedOneWithoutPostsInput
    user: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutImagesInput = {
    id?: number
    userId: number
    categoryId: number
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
  }

  export type PostCreateOrConnectWithoutImagesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
  }

  export type PostUpsertWithoutImagesInput = {
    update: XOR<PostUpdateWithoutImagesInput, PostUncheckedUpdateWithoutImagesInput>
    create: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
  }

  export type PostUpdateWithoutImagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutPostsInput
    user?: UserUpdateOneRequiredWithoutPostsInput
  }

  export type PostUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttributeValuesCreateWithoutAttributeInput = {
    value: number
  }

  export type AttributeValuesUncheckedCreateWithoutAttributeInput = {
    id?: number
    value: number
  }

  export type AttributeValuesCreateOrConnectWithoutAttributeInput = {
    where: AttributeValuesWhereUniqueInput
    create: XOR<AttributeValuesCreateWithoutAttributeInput, AttributeValuesUncheckedCreateWithoutAttributeInput>
  }

  export type AttributeValuesCreateManyAttributeInputEnvelope = {
    data: Enumerable<AttributeValuesCreateManyAttributeInput>
    skipDuplicates?: boolean
  }

  export type AttributeValuesUpsertWithWhereUniqueWithoutAttributeInput = {
    where: AttributeValuesWhereUniqueInput
    update: XOR<AttributeValuesUpdateWithoutAttributeInput, AttributeValuesUncheckedUpdateWithoutAttributeInput>
    create: XOR<AttributeValuesCreateWithoutAttributeInput, AttributeValuesUncheckedCreateWithoutAttributeInput>
  }

  export type AttributeValuesUpdateWithWhereUniqueWithoutAttributeInput = {
    where: AttributeValuesWhereUniqueInput
    data: XOR<AttributeValuesUpdateWithoutAttributeInput, AttributeValuesUncheckedUpdateWithoutAttributeInput>
  }

  export type AttributeValuesUpdateManyWithWhereWithoutAttributeInput = {
    where: AttributeValuesScalarWhereInput
    data: XOR<AttributeValuesUpdateManyMutationInput, AttributeValuesUncheckedUpdateManyWithoutValuesInput>
  }

  export type AttributeValuesScalarWhereInput = {
    AND?: Enumerable<AttributeValuesScalarWhereInput>
    OR?: Enumerable<AttributeValuesScalarWhereInput>
    NOT?: Enumerable<AttributeValuesScalarWhereInput>
    id?: IntFilter | number
    attributeId?: IntFilter | number
    value?: IntFilter | number
  }

  export type AttributeCreateWithoutValuesInput = {

  }

  export type AttributeUncheckedCreateWithoutValuesInput = {
    id?: number
  }

  export type AttributeCreateOrConnectWithoutValuesInput = {
    where: AttributeWhereUniqueInput
    create: XOR<AttributeCreateWithoutValuesInput, AttributeUncheckedCreateWithoutValuesInput>
  }

  export type AttributeUpsertWithoutValuesInput = {
    update: XOR<AttributeUpdateWithoutValuesInput, AttributeUncheckedUpdateWithoutValuesInput>
    create: XOR<AttributeCreateWithoutValuesInput, AttributeUncheckedCreateWithoutValuesInput>
  }

  export type AttributeUpdateWithoutValuesInput = {

  }

  export type AttributeUncheckedUpdateWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PostCreateManyUserInput = {
    id?: number
    categoryId: number
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
  }

  export type PostUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutPostsInput
    images?: ImageUpdateManyWithoutPostInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
    images?: ImageUncheckedUpdateManyWithoutPostInput
  }

  export type PostUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateManyLanguageInput = {
    id?: number
    email: string
    firstName: string
    lastName: string
    password: string
    phone: string
    countyId: number
    zip: string
    isPrivacyEneable?: boolean
    role?: Role
  }

  export type UserUpdateWithoutLanguageInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countyId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
    isPrivacyEneable?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | Role
    posts?: PostUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutLanguageInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countyId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
    isPrivacyEneable?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | Role
    posts?: PostUncheckedUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countyId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
    isPrivacyEneable?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type CountyCreateManyCityInput = {
    id?: number
    name: string
  }

  export type CountyUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountyUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CountyUncheckedUpdateManyWithoutCountiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateManyStateInput = {
    id?: number
    name: string
  }

  export type CityUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    counties?: CountyUpdateManyWithoutCityInput
  }

  export type CityUncheckedUpdateWithoutStateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    counties?: CountyUncheckedUpdateManyWithoutCityInput
  }

  export type CityUncheckedUpdateManyWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StateCreateManyCountryInput = {
    id?: number
    name: string
  }

  export type StateUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutStateInput
  }

  export type StateUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutStateInput
  }

  export type StateUncheckedUpdateManyWithoutStatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateManyCurrencyInput = {
    id?: number
    method: string
    status: string
  }

  export type CountryCreateManyCurrencyInput = {
    id?: number
    name: string
  }

  export type PaymentUpdateWithoutCurrencyInput = {
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUncheckedUpdateWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUpdateWithoutCurrencyInput = {
    name?: StringFieldUpdateOperationsInput | string
    states?: StateUpdateManyWithoutCountryInput
  }

  export type CountryUncheckedUpdateWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    states?: StateUncheckedUpdateManyWithoutCountryInput
  }

  export type CountryUncheckedUpdateManyWithoutCountriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateManyParentInput = {
    id?: number
    name: string
    maxImgs: number
    postValidityIntervalInDays?: number | null
  }

  export type PostCreateManyCategoryInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    lastRenewedAt?: Date | string
    title: string
    detail: string
    isActive?: boolean
    isSeller: boolean
    isIndividual: boolean
    expectedPrice?: number | null
    isPriceNegotiable: boolean
  }

  export type PropertyCreateManyCategoryInput = {
    id?: number
    name: string
    unit: string
    isMandatory: boolean
    screenControlId: number
  }

  export type CategoryUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
    children?: CategoryUpdateManyWithoutParentInput
    posts?: PostUpdateManyWithoutCategoryInput
    properties?: PropertyUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
    posts?: PostUncheckedUpdateManyWithoutCategoryInput
    properties?: PropertyUncheckedUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateManyWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    maxImgs?: IntFieldUpdateOperationsInput | number
    postValidityIntervalInDays?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PostUpdateWithoutCategoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutPostsInput
    images?: ImageUpdateManyWithoutPostInput
  }

  export type PostUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRenewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSeller?: BoolFieldUpdateOperationsInput | boolean
    isIndividual?: BoolFieldUpdateOperationsInput | boolean
    expectedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isPriceNegotiable?: BoolFieldUpdateOperationsInput | boolean
    images?: ImageUncheckedUpdateManyWithoutPostInput
  }

  export type PropertyUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    values?: PossibleValuesUpdateManyWithoutPropertyInput
    screenControl?: ScreenControlUpdateOneRequiredWithoutPropertyInput
  }

  export type PropertyUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    screenControlId?: IntFieldUpdateOperationsInput | number
    values?: PossibleValuesUncheckedUpdateManyWithoutPropertyInput
  }

  export type PropertyUncheckedUpdateManyWithoutPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    screenControlId?: IntFieldUpdateOperationsInput | number
  }

  export type PossibleValuesCreateManyPropertyInput = {
    id?: number
    value: number
  }

  export type PossibleValuesUpdateWithoutPropertyInput = {
    value?: IntFieldUpdateOperationsInput | number
  }

  export type PossibleValuesUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type PossibleValuesUncheckedUpdateManyWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type PropertyCreateManyScreenControlInput = {
    id?: number
    categoryId: number
    name: string
    unit: string
    isMandatory: boolean
  }

  export type PropertyUpdateWithoutScreenControlInput = {
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    values?: PossibleValuesUpdateManyWithoutPropertyInput
    Category?: CategoryUpdateOneWithoutPropertiesInput
  }

  export type PropertyUncheckedUpdateWithoutScreenControlInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    values?: PossibleValuesUncheckedUpdateManyWithoutPropertyInput
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImageCreateManyPostInput = {
    id?: number
    name: string
    url: string
  }

  export type ImageUpdateWithoutPostInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUncheckedUpdateManyWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type AttributeValuesCreateManyAttributeInput = {
    id?: number
    value: number
  }

  export type AttributeValuesUpdateWithoutAttributeInput = {
    value?: IntFieldUpdateOperationsInput | number
  }

  export type AttributeValuesUncheckedUpdateWithoutAttributeInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type AttributeValuesUncheckedUpdateManyWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}